# ==============================================================================
# AUTOGENERATED FILE - DO NOT MODIFY
# This file was generated by the script `generate_interface_commands.py`.
# Any modifications may be overwritten.
# Generated on: 2024-09-10 09:57:46
# ==============================================================================

from __future__ import annotations

import contextlib
import datetime
import logging
import pathlib
import typing
from dataclasses import asdict
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np
from pydantic import ConfigDict, dataclasses
from typing_extensions import Literal, override

from .plotting import MatplotlibGraphManager
from .plotting.types import ShapeListInfo
from .plotting.util import select_graph_manager_class
from .tao_ctypes.core import TaoCore, TaoInitializationError
from .tao_ctypes.util import parse_tao_python_data
from .util import parsers as _pytao_parsers
from .util.command import make_tao_init
from .util.parameters import tao_parameter_dict

if typing.TYPE_CHECKING:
    from .plotting.bokeh import BokehGraphManager, NotebookGraphManager  # noqa: F401
    from .subproc import SubprocessTao

    AnyTao = Union["Tao", SubprocessTao]


logger = logging.getLogger(__name__)
AnyPath = Union[pathlib.Path, str]


@dataclasses.dataclass(config=ConfigDict(extra="forbid", validate_assignment=True))
class TaoStartup:
    """
    All Tao startup settings.

    Attributes
    ----------
    init : str, optional
        Initialization string for Tao.  Same as the tao command-line, including
        "-init" and such.  Shell variables in `init` strings will be expanded
        by Tao.  For example, an `init` string containing `$HOME` would be
        replaced by your home directory.
    so_lib : str, optional
        Path to the Tao shared library.  Auto-detected if not specified.
    plot : str, bool, optional
        Use pytao's plotting mechanism with matplotlib or bokeh, if available.
        If `True`, pytao will pick an appropriate plotting backend.
        If `False` or "tao", Tao plotting will be used. (Default)
        If "mpl", the pytao matplotlib plotting backend will be selected.
        If "bokeh", the pytao Bokeh plotting backend will be selected.
    metadata : dict[str, Any], optional
        User-specified metadata about this startup.  Not passed to Tao.
    beam_file : str or pathlib.Path, default=None
        File containing the tao_beam_init namelist.
    beam_init_position_file : pathlib.Path or str, default=None
        File containing initial particle positions.
    building_wall_file : str or pathlib.Path, default=None
        Define the building tunnel wall
    command : str, optional
        Commands to run after startup file commands
    data_file : str or pathlib.Path, default=None
        Define data for plotting and optimization
    debug : bool, default=False
        Debug mode for Wizards
    disable_smooth_line_calc : bool, default=False
        Disable the smooth line calc used in plotting
    external_plotting : bool, default=False
        Tells Tao that plotting is done externally to Tao.
    geometry : "wxh" or (width, height) tuple, optional
        Plot window geometry (pixels)
    hook_init_file :  pathlib.Path or str, default=None
        Init file for hook routines (Default = tao_hook.init)
    init_file : str or pathlib.Path, default=None
        Tao init file
    lattice_file : str or pathlib.Path, default=None
        Bmad lattice file
    log_startup : bool, default=False
        Write startup debugging info
    no_stopping : bool, default=False
        For debugging : Prevents Tao from exiting on errors
    noinit : bool, default=False
        Do not use Tao init file.
    noplot : bool, default=False
        Do not open a plotting window
    nostartup : bool, default=False
        Do not open a startup command file
    no_rad_int : bool, default=False
        Do not do any radiation integrals calculations.
    plot_file : str or pathlib.Path, default=None
        Plotting initialization file
    prompt_color : str, optional
        Set color of prompt string. Default is blue.
    reverse : bool, default=False
        Reverse lattice element order?
    rf_on : bool, default=False
        Use "--rf_on" to turn off RF (default is now RF on)
    quiet : bool, default=False
        Suppress terminal output when running a command file?
    slice_lattice : str, optional
        Discards elements from lattice that are not in the list
    start_branch_at : str, optional
        Start lattice branch at element.
    startup_file : str or pathlib.Path, default=None
        Commands to run after parsing Tao init file
    symbol_import : bool, default=False
        Import symbols defined in lattice files(s)?
    var_file : str or pathlib.Path, default=None
        Define variables for plotting and optimization
    """

    # General case 'init' string:
    init: str = dataclasses.Field(default="", kw_only=False)

    # Tao ctypes-specific - shared library location.
    so_lib: str = dataclasses.Field(default="", kw_only=False)

    # pytao specific
    metadata: Dict[str, Any] = dataclasses.Field(default_factory=dict)
    plot: Union[str, bool] = "tao"

    # All remaining flags:
    beam_file: Optional[AnyPath] = None
    beam_init_position_file: Optional[AnyPath] = None
    building_wall_file: Optional[AnyPath] = None
    command: str = ""
    data_file: Optional[AnyPath] = None
    debug: bool = False
    disable_smooth_line_calc: bool = False
    external_plotting: bool = False
    geometry: Union[str, Tuple[int, int]] = ""
    hook_init_file: Optional[AnyPath] = None
    init_file: Optional[AnyPath] = None
    lattice_file: Optional[AnyPath] = None
    log_startup: bool = False
    no_stopping: bool = False
    noinit: bool = False
    noplot: bool = False
    nostartup: bool = False
    no_rad_int: bool = False
    plot_file: Optional[AnyPath] = None
    prompt_color: str = ""
    reverse: bool = False
    rf_on: bool = False
    quiet: bool = False
    slice_lattice: str = ""
    start_branch_at: str = ""
    startup_file: Optional[AnyPath] = None
    symbol_import: bool = False
    var_file: Optional[AnyPath] = None

    @property
    def tao_class_params(self) -> Dict[str, Any]:
        """Parameters used to initialize Tao or make a new Tao instance."""
        # TODO: handle abbreviated/shortened keys from the user
        init_parts = self.init.split()
        params = {
            key: value
            for key, value in asdict(self).items()
            if value != getattr(type(self), key, None) and f"-{key}" not in init_parts
        }
        params["init"] = self.init
        params.pop("metadata")

        geometry = params.get("geometry", "")
        if not isinstance(geometry, str):
            width, height = geometry
            params["geometry"] = f"{width}x{height}"
        return params

    @property
    def can_initialize(self) -> bool:
        """
        Can Tao be initialized with these settings?

        Tao requires one or more of the following to be initialized:

        * `-init_file` to specify the initialization file.
        * `-lattice_file` to specify the lattice file.

        These are commonly shortened to `-init` or `-lat`.  Tao accepts
        shortened flags if they are not ambiguous.
        """
        tao_init_parts = self.tao_init.split()
        return any(part.startswith(flag) for part in tao_init_parts for flag in {"-i", "-la"})

    @property
    def tao_init(self) -> str:
        """Tao.init() command string."""
        params = self.tao_class_params
        # For tao.init(), we throw away Tao class-specific things:
        params.pop("so_lib", None)
        params.pop("plot", None)
        return make_tao_init(**params)

    def run(self, use_subprocess: bool = False) -> AnyTao:
        """Create a new Tao instance and run it using these settings."""
        params = self.tao_class_params
        if use_subprocess:
            from .subproc import SubprocessTao

            return SubprocessTao(**params)
        return Tao(**params)

    @contextlib.contextmanager
    def run_context(self, use_subprocess: bool = False):
        """
        Create a new Tao instance and run it using these settings in a context manager.

        Yields
        ------
        Tao
            Tao instance.
        """
        tao = self.run(use_subprocess=use_subprocess)

        try:
            yield tao
        finally:
            from .subproc import SubprocessTao

            if isinstance(tao, SubprocessTao):
                tao.close_subprocess()


class Tao(TaoCore):
    """
    Communicate with Tao using ctypes.

    Parameters
    ----------
    init : str, optional
        Initialization string for Tao.  Same as the tao command-line, including
        "-init" and such.  Shell variables in `init` strings will be expanded
        by Tao.  For example, an `init` string containing `$HOME` would be
        replaced by your home directory.
    so_lib : str, optional
        Path to the Tao shared library.  Auto-detected if not specified.
    plot : str, bool, optional
        Use pytao's plotting mechanism with matplotlib or bokeh, if available.
        If `True`, pytao will pick an appropriate plotting backend.
        If `False` or "tao", Tao plotting will be used. (Default)
        If "mpl", the pytao matplotlib plotting backend will be selected.
        If "bokeh", the pytao Bokeh plotting backend will be selected.

    beam_file : str or pathlib.Path, default=None
        File containing the tao_beam_init namelist.
    beam_init_position_file : pathlib.Path or str, default=None
        File containing initial particle positions.
    building_wall_file : str or pathlib.Path, default=None
        Define the building tunnel wall
    command : str, optional
        Commands to run after startup file commands
    data_file : str or pathlib.Path, default=None
        Define data for plotting and optimization
    debug : bool, default=False
        Debug mode for Wizards
    disable_smooth_line_calc : bool, default=False
        Disable the smooth line calc used in plotting
    external_plotting : bool, default=False
        Tells Tao that plotting is done externally to Tao.
    geometry : "wxh" or (width, height) tuple, optional
        Plot window geometry (pixels)
    hook_init_file :  pathlib.Path or str, default=None
        Init file for hook routines (Default = tao_hook.init)
    init_file : str or pathlib.Path, default=None
        Tao init file
    lattice_file : str or pathlib.Path, default=None
        Bmad lattice file
    log_startup : bool, default=False
        Write startup debugging info
    no_stopping : bool, default=False
        For debugging : Prevents Tao from exiting on errors
    noinit : bool, default=False
        Do not use Tao init file.
    noplot : bool, default=False
        Do not open a plotting window
    nostartup : bool, default=False
        Do not open a startup command file
    no_rad_int : bool, default=False
        Do not do any radiation integrals calculations.
    plot_file : str or pathlib.Path, default=None
        Plotting initialization file
    prompt_color : str, optional
        Set color of prompt string. Default is blue.
    reverse : bool, default=False
        Reverse lattice element order?
    rf_on : bool, default=False
        Use "--rf_on" to turn off RF (default is now RF on)
    quiet : bool, default=False
        Suppress terminal output when running a command file?
    slice_lattice : str, optional
        Discards elements from lattice that are not in the list
    start_branch_at : str, optional
        Start lattice branch at element.
    startup_file : str or pathlib.Path, default=None
        Commands to run after parsing Tao init file
    symbol_import : bool, default=False
        Import symbols defined in lattice files(s)?
    var_file : str or pathlib.Path, default=None
        Define variables for plotting and optimization

    Attributes
    ----------
    plot_backend_name : str or None
        Plotting backend name, if using pytao plotting. `None` indicates that
        internal Tao plotting is to be used.
        Changing the backend may require reinitialization to enable external
        plotting.
    init_output : list of str
        Tao initialization output, recorded when the Tao object first
        initializes.  Subsequent calls to `init()` will override this variable.
    """

    plot_backend_name: Optional[str]
    _graph_managers: dict
    _min_tao_version = datetime.datetime(2024, 8, 4)

    @override
    def __init__(
        self,
        init: str = "",
        so_lib: str = "",
        *,
        plot: Union[str, bool] = "tao",
        beam_file: Optional[AnyPath] = None,
        beam_init_position_file: Optional[AnyPath] = None,
        building_wall_file: Optional[AnyPath] = None,
        command: str = "",
        data_file: Optional[AnyPath] = None,
        debug: bool = False,
        disable_smooth_line_calc: bool = False,
        external_plotting: bool = False,
        geometry: Union[str, Tuple[int, int]] = "",
        hook_init_file: Optional[AnyPath] = None,
        init_file: Optional[AnyPath] = None,
        lattice_file: Optional[AnyPath] = None,
        log_startup: bool = False,
        no_stopping: bool = False,
        noinit: bool = False,
        noplot: bool = False,
        nostartup: bool = False,
        no_rad_int: bool = False,
        plot_file: Optional[AnyPath] = None,
        prompt_color: str = "",
        reverse: bool = False,
        rf_on: bool = False,
        quiet: bool = False,
        slice_lattice: str = "",
        start_branch_at: str = "",
        startup_file: Optional[AnyPath] = None,
        symbol_import: bool = False,
        var_file: Optional[AnyPath] = None,
    ):
        self._init_shared_library(so_lib=so_lib)
        self.plot_backend_name = None
        self._graph_managers = {}
        self._tao_version_checked = False
        # NOTE: do not call super() here - we handle the init arguments on our
        # own.
        # super().__init__(init="", so_lib=so_lib)
        self.init(
            cmd=init,
            plot=plot,
            beam_file=beam_file,
            beam_init_position_file=beam_init_position_file,
            building_wall_file=building_wall_file,
            command=command,
            data_file=data_file,
            debug=debug,
            disable_smooth_line_calc=disable_smooth_line_calc,
            external_plotting=external_plotting,
            geometry=geometry,
            hook_init_file=hook_init_file,
            init_file=init_file,
            lattice_file=lattice_file,
            log_startup=log_startup,
            no_stopping=no_stopping,
            noinit=noinit,
            noplot=noplot,
            nostartup=nostartup,
            no_rad_int=no_rad_int,
            plot_file=plot_file,
            prompt_color=prompt_color,
            reverse=reverse,
            rf_on=rf_on,
            quiet=quiet,
            slice_lattice=slice_lattice,
            start_branch_at=start_branch_at,
            startup_file=startup_file,
            symbol_import=symbol_import,
            var_file=var_file,
        )
        try:
            self.register_cell_magic()
        except Exception:
            logger.debug("Failed to register cell magic", exc_info=True)

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} init={self.init_settings.tao_init!r} so_lib_file={self.so_lib_file!r}>"

    @override
    def init(
        self,
        cmd: str = "",
        *,
        plot: Union[str, bool] = "tao",
        beam_file: Optional[AnyPath] = None,
        beam_init_position_file: Optional[AnyPath] = None,
        building_wall_file: Optional[AnyPath] = None,
        command: str = "",
        data_file: Optional[AnyPath] = None,
        debug: bool = False,
        disable_smooth_line_calc: bool = False,
        external_plotting: bool = False,
        geometry: Union[str, Tuple[int, int]] = "",
        hook_init_file: Optional[AnyPath] = None,
        init_file: Optional[AnyPath] = None,
        lattice_file: Optional[AnyPath] = None,
        log_startup: bool = False,
        no_stopping: bool = False,
        noinit: bool = False,
        noplot: bool = False,
        nostartup: bool = False,
        no_rad_int: bool = False,
        plot_file: Optional[AnyPath] = None,
        prompt_color: str = "",
        reverse: bool = False,
        rf_on: bool = False,
        quiet: bool = False,
        slice_lattice: str = "",
        start_branch_at: str = "",
        startup_file: Optional[AnyPath] = None,
        symbol_import: bool = False,
        var_file: Optional[AnyPath] = None,
    ) -> List[str]:
        """
        (Re-)Initialize Tao with the given command.

        Parameters
        ----------
        init : str, optional
            Initialization string for Tao.  Same as the tao command-line, including
            "-init" and such.  Shell variables in `init` strings will be expanded
            by Tao.  For example, an `init` string containing `$HOME` would be
            replaced by your home directory.
        so_lib : str, optional
            Path to the Tao shared library.  Auto-detected if not specified.
        plot : str, bool, optional
            Use pytao's plotting mechanism with matplotlib or bokeh, if available.
            If `True`, pytao will pick an appropriate plotting backend.
            If `False` or "tao", Tao plotting will be used. (Default)
            If "mpl", the pytao matplotlib plotting backend will be selected.
            If "bokeh", the pytao Bokeh plotting backend will be selected.

        beam_file : str or pathlib.Path, default=None
            File containing the tao_beam_init namelist.
        beam_init_position_file : pathlib.Path or str, default=None
            File containing initial particle positions.
        building_wall_file : str or pathlib.Path, default=None
            Define the building tunnel wall
        command : str, optional
            Commands to run after startup file commands
        data_file : str or pathlib.Path, default=None
            Define data for plotting and optimization
        debug : bool, default=False
            Debug mode for Wizards
        disable_smooth_line_calc : bool, default=False
            Disable the smooth line calc used in plotting
        external_plotting : bool, default=False
            Tells Tao that plotting is done externally to Tao.
        geometry : "wxh" or (width, height) tuple, optional
            Plot window geometry (pixels)
        hook_init_file :  pathlib.Path or str, default=None
            Init file for hook routines (Default = tao_hook.init)
        init_file : str or pathlib.Path, default=None
            Tao init file
        lattice_file : str or pathlib.Path, default=None
            Bmad lattice file
        log_startup : bool, default=False
            Write startup debugging info
        no_stopping : bool, default=False
            For debugging : Prevents Tao from exiting on errors
        noinit : bool, default=False
            Do not use Tao init file.
        noplot : bool, default=False
            Do not open a plotting window
        nostartup : bool, default=False
            Do not open a startup command file
        no_rad_int : bool, default=False
            Do not do any radiation integrals calculations.
        plot_file : str or pathlib.Path, default=None
            Plotting initialization file
        prompt_color : str, optional
            Set color of prompt string. Default is blue.
        reverse : bool, default=False
            Reverse lattice element order?
        rf_on : bool, default=False
            Use "--rf_on" to turn off RF (default is now RF on)
        quiet : bool, default=False
            Suppress terminal output when running a command file?
        slice_lattice : str, optional
            Discards elements from lattice that are not in the list
        start_branch_at : str, optional
            Start lattice branch at element.
        startup_file : str or pathlib.Path, default=None
            Commands to run after parsing Tao init file
        symbol_import : bool, default=False
            Import symbols defined in lattice files(s)?
        var_file : str or pathlib.Path, default=None
            Define variables for plotting and optimization

        Returns
        -------
        list of str
            Tao's initialization output.
        """
        if plot in {"mpl", "bokeh"}:
            self.plot_backend_name = plot
        else:
            self.plot_backend_name = None

        use_pytao_plotting = plot in {"mpl", "bokeh", True}

        self.init_settings = TaoStartup(
            init=cmd,
            plot=plot,
            beam_file=beam_file,
            beam_init_position_file=beam_init_position_file,
            building_wall_file=building_wall_file,
            command=command,
            data_file=data_file,
            debug=debug,
            disable_smooth_line_calc=disable_smooth_line_calc,
            external_plotting=use_pytao_plotting or external_plotting,
            geometry=geometry,
            hook_init_file=hook_init_file,
            init_file=init_file,
            lattice_file=lattice_file,
            log_startup=log_startup,
            no_stopping=no_stopping,
            noinit=noinit,
            noplot=use_pytao_plotting or noplot,
            nostartup=nostartup,
            no_rad_int=no_rad_int,
            plot_file=plot_file,
            prompt_color=prompt_color,
            reverse=reverse,
            rf_on=rf_on,
            quiet=quiet,
            slice_lattice=slice_lattice,
            start_branch_at=start_branch_at,
            startup_file=startup_file,
            symbol_import=symbol_import,
            var_file=var_file,
        )

        if not self.init_settings.can_initialize:
            raise TaoInitializationError(
                f"Tao will not be able to initialize with the following settings:"
                f"\n"
                f"\ninit={self.init_settings.tao_init!r}"
                f"\n"
                f"\nIn order to initialize a Tao object, you must specify at least one of these:"
                f"\n * `init_file` with a valid filename"
                f"\n * `lattice_file` with a valid filename"
                f"\n"
                f"\nFor example:"
                f"\n>>> Tao(init_file='$ACC_ROOT_DIR/bmad-doc/tao_examples/erl/tao.init')"
                f"\n"
                f"\nAlternatively, you may pass the full command-line arguments:"
                f"\n>>> Tao('-lat $ACC_ROOT_DIR/bmad-doc/tao_examples/erl/bmad.lat')"
            )

        self._init_output = self._init(self.init_settings)
        if not self._tao_version_checked:
            self._tao_version_checked = True
            self._check_tao_version()
        return self._init_output

    def _check_tao_version(self):
        version = self.version()
        if version is None:
            # Don't continue to warn about failing to parse the version
            return

        if version.date() < self._min_tao_version.date():
            logger.warning(
                f"Installed Tao version is lower than pytao's recommended and tested version. "
                f"\n   You have Tao version: {version.date()}"
                f"\n   Recommended version:  {self._min_tao_version.date()}"
                f"\nSome features may not work as expected.  Please upgrade bmad."
            )

    def _reset_graph_managers(self) -> None:
        for manager in self._graph_managers.values():
            try:
                manager.tao_init_hook()
            except Exception:
                logger.exception(
                    "Tao plot manager re-initialization failure (%s)", type(manager)
                )

    def _init(self, startup: TaoStartup):
        self._reset_graph_managers()
        return super().init(startup.tao_init)

    def __execute(
        self,
        cmd: str,
        as_dict: bool = True,
        raises: bool = True,
        method_name=None,
        cmd_type: str = "string_list",
    ):
        """

        A wrapper to handle commonly used options when running a command through tao.

        Parameters
        ----------
        cmd : str
            The command to run
        as_dict : bool, optional
            Return string data as a dict? by default True
        raises : bool, optional
            Raise exception on tao errors? by default True
        method_name : str/None, optional
            Name of the caller. Required for custom parsers for commands, by
            default None
        cmd_type : str, optional
            The type of data returned by tao in its common memory, by default
            "string_list"

        Returns
        -------
        Any
        Result from running tao. The type of data depends on configuration, but is generally a list of strings, a dict, or a
        numpy array.
        """
        func_for_type = {
            "string_list": self.cmd,
            "real_array": self.cmd_real,
            "integer_array": self.cmd_integer,
        }
        func = func_for_type.get(cmd_type, self.cmd)
        raw_output = func(cmd, raises=raises)
        special_parser = getattr(_pytao_parsers, f"parse_{method_name}", None)
        try:
            if special_parser and callable(special_parser):
                return special_parser(raw_output, cmd=cmd)
            if "string" not in cmd_type:
                return raw_output
            if as_dict:
                return parse_tao_python_data(raw_output)
            return tao_parameter_dict(raw_output)
        except Exception as ex:
            if raises:
                ex.tao_output = raw_output
                raise
            logger.exception(
                "Failed to parse string data with custom parser. Returning raw value."
            )
            return raw_output

    def bunch_data(self, ele_id, *, which="model", ix_bunch=1, verbose=False):
        """
        Returns bunch data in openPMD-beamphysics format/notation.

        Notes
        -----
        Note that Tao's 'write beam' will also write a proper h5 file in this format.

        Expected usage:
            data = bunch_data(tao, 'end')
            from pmd_beamphysics import ParticleGroup
            P = ParicleGroup(data=data)


        Returns
        -------
        data : dict
            dict of arrays, with keys 'x', 'px', 'y', 'py', 't', 'pz',
            'status', 'weight', 'z', 'species'


        Examples
        --------
        Example: 1
        init: $ACC_ROOT_DIR/tao/examples/csr_beam_tracking/tao.init
        args:
        ele_id: end
        which: model
        ix_bunch: 1

        """

        # Get species
        stats = self.bunch_params(ele_id, which=which, verbose=verbose)
        species = stats["species"]

        dat = {}
        for coordinate in ["x", "px", "y", "py", "t", "pz", "p0c", "charge", "state"]:
            dat[coordinate] = self.bunch1(
                ele_id,
                coordinate=coordinate,
                which=which,
                ix_bunch=ix_bunch,
                verbose=verbose,
            )

        # Remove normalizations
        p0c = dat.pop("p0c")

        dat["status"] = dat.pop("state")
        dat["weight"] = dat.pop("charge")

        # px from Bmad is px/p0c
        # pz from Bmad is delta = p/p0c -1.
        # pz = sqrt( (delta+1)**2 -px**2 -py**2)*p0c
        dat["pz"] = np.sqrt((dat["pz"] + 1) ** 2 - dat["px"] ** 2 - dat["py"] ** 2) * p0c
        dat["px"] = dat["px"] * p0c
        dat["py"] = dat["py"] * p0c

        # z = 0 by definition
        dat["z"] = np.full(len(dat["x"]), 0)

        dat["species"] = species.lower()

        return dat

    def cmds(self, cmds, suppress_lattice_calc=True, suppress_plotting=True, raises=True):
        """
        Runs a list of commands, optionally suppressing lattice calculations
        and plotting updates.

        Parameters
        ----------
        cmds : list of str
            List of string commands.
        suppress_lattice_calc : bool, default=True
            Suppress lattice calc when applying the commands.
        suppress_plotting  : bool, default=True
            Suppress plotting when applying commands.
        raises : bool, default=True
            Raise an exception of [ERROR or [FATAL is detected in the output.

        Returns
        -------
        list
            Results corresponding to the commands

        """
        # Get globals to detect plotting
        g = self.tao_global()
        ploton, laton = g["plot_on"], g["lattice_calc_on"]

        if suppress_plotting and ploton:
            self.cmd("set global plot_on = F")
        if suppress_lattice_calc and laton:
            self.cmd("set global lattice_calc_on = F")

        # Actually apply commands
        results = []
        for cmd in cmds:
            res = self.cmd(cmd, raises=raises)
            results.append(res)

        if suppress_plotting and ploton:
            self.cmd("set global plot_on = T")
        if suppress_lattice_calc and laton:
            self.cmd("set global lattice_calc_on = T")

        return results

    def version(self) -> Optional[datetime.datetime]:
        """Get the date-coded version."""
        cmd = "show version"
        return _pytao_parsers.parse_show_version(self.cmd(cmd), cmd=cmd)

    def plot_page(self):
        """Get plot page parameters."""
        cmd = "show plot_page"
        return _pytao_parsers.parse_show_plot_page(self.cmd(cmd), cmd=cmd)

    def _get_graph_manager_by_key(self, key: str):
        graph_manager = self._graph_managers.get(key, None)

        if graph_manager is None:
            if key == "bokeh":
                from .plotting.bokeh import select_graph_manager_class

                cls = select_graph_manager_class()
            elif key == "mpl":
                from .plotting.mpl import MatplotlibGraphManager as cls

            else:
                raise NotImplementedError(key)

            graph_manager = cls(self)
            self._graph_managers[key] = graph_manager
        return graph_manager

    @property
    def matplotlib(self) -> MatplotlibGraphManager:
        """Get the Matplotlib graph manager."""
        return typing.cast(MatplotlibGraphManager, self._get_graph_manager_by_key("mpl"))

    @property
    def bokeh(self) -> BokehGraphManager:
        """Get the Bokeh graph manager."""
        from .plotting.bokeh import BokehGraphManager

        return typing.cast(BokehGraphManager, self._get_graph_manager_by_key("bokeh"))

    @property
    def plot_manager(
        self,
    ) -> Union[BokehGraphManager, NotebookGraphManager, MatplotlibGraphManager]:
        """
        The currently-configured plot graph manager.

        This can be configured at initialization time by specifying
        `plot="mpl"`, for example.
        This may also be reconfigured by changing the attribute
        `plot_backend_name`.
        """
        return self._get_graph_manager_by_key(self.plot_backend_name or "mpl")

    def _get_user_specified_backend(self, backend: Optional[str]):
        if backend is None:
            backend = self.plot_backend_name or select_graph_manager_class()._key_

        if not self.init_settings.external_plotting:
            raise RuntimeError(
                "Tao was not configured for external plotting, which pytao requires. "
                "Please re-initialize Tao and set `plot=True` (or specify a backend). "
                "For example: tao.init(..., plot=True)"
            )

        if backend not in {"mpl", "bokeh"}:
            raise ValueError(f"Unsupported backend: {backend}")

        return self._get_graph_manager_by_key(backend)

    def update_plot_shapes(
        self,
        ele_name: Optional[str] = None,
        *,
        layout: bool = False,
        floor: bool = False,
        shape_index: Optional[int] = None,
        shape: Optional[str] = None,
        color: Optional[str] = None,
        shape_size: Optional[float] = None,
        type_label: Optional[Literal["s", "name", "none"]] = None,
        shape_draw: Optional[bool] = None,
        multi_shape: Optional[bool] = None,
        line_width: Optional[int] = None,
    ) -> List[ShapeListInfo]:
        """
        Update shape plotting settings for layouts/floor plans.

        * Must set either (or both of) `layout` / `floor` to `True`.
        * Only the specified parameters will be updated for each shape. That is,
          if you only specify `color` then the color of every matching shape
          will be updated and the other settings (such as `line_width`) will
          remain the same.

        Parameters
        ----------
        ele_name : str, optional
            Update the shape only for this element name.
            If `ele_name` and `shape_index` are unspecified, these settings
            apply to all shapes.
        shape_index : int, optional
            The numerical index of the shape to change.
            If `ele_name` and `shape_index` are unspecified, these settings
            apply to all shapes.
        layout : bool, default=False
            Apply the settings to lattice layout shapes.
        floor : bool, default=False
            Apply the settings to floor plan shapes.
        shape : str, optional
            The shape to use. Choose from one of the following:
            * "box"
            * "xbox"
            * "bow_tie"
            * "rbow_tie"
            * "circle"
            * "diamond"
            * "x",
            * "r_triangle"
            * "l_triangle"
            * "u_triangle"
            * "d_triangle"
        color : str, optional
            Color for the shape. Choose from one of the following:
            * "Not_Set"
            * "White"
            * "Black"
            * "Red"
            * "Green"
            * "Blue"
            * "Cyan"
            * "Magenta"
            * "Yellow"
            * "Orange"
            * "Yellow_Green"
            * "Light_Green"
            * "Navy_Blue"
            * "Purple"
            * "Reddish_Purple"
            * "Dark_Grey"
            * "Light_Grey"
            * "Transparent"
        shape_size : float, optional
            Shape size.
        type_label : "s", "name", or "none", optional
            Show this label for each shape. `None` indicates no shape.
        shape_draw : bool, optional
            Draw the shape.
        multi_shape : bool, optional
            If it can be part of a multi-shape.
        line_width : int, optional
            Width of lines used to draw the shape.

        Returns
        -------
        list of ShapeListInfo
        """

        who_list = []
        if layout:
            who_list.append("lat_layout")
        if floor:
            who_list.append("floor_plan")
        if not who_list:
            raise ValueError("Must specify either `layout` or `floor` plots")

        res = []
        for who in who_list:
            shape_list_info = typing.cast(List[ShapeListInfo], self.shape_list(who))
            res.extend(shape_list_info)
            for info in shape_list_info:
                should_set = any(
                    (
                        (ele_name is None and shape_index is None),
                        (ele_name == info["ele_name"]),
                        (ele_name and info["ele_name"].startswith(ele_name)),
                        (shape_index == info["shape_index"]),
                    )
                )
                if not should_set:
                    continue

                if type_label is not None:
                    info["type_label"] = type_label
                if shape is not None:
                    info["shape"] = shape
                if color is not None:
                    info["color"] = color
                if shape_size is not None:
                    info["shape_size"] = shape_size
                if shape_draw is not None:
                    info["shape_draw"] = shape_draw
                if multi_shape is not None:
                    info["multi_shape"] = multi_shape
                if line_width is not None:
                    info["line_width"] = line_width

                self.shape_set(who=who, **info)

        return res

    def plot(
        self,
        template: Optional[Union[str, List[str]]] = None,
        *,
        region_name: Optional[str] = None,
        include_layout: bool = True,
        width: Optional[int] = None,
        height: Optional[int] = None,
        layout_height: Optional[int] = None,
        share_x: Optional[bool] = None,
        backend: Optional[str] = None,
        grid: Optional[Tuple[int, int]] = None,
        **kwargs,
    ) -> None:
        """
        Make a plot with the provided backend.

        Plot a graph, or all placed graphs.

        To plot a specific graph, specify `template` (optionally `region_name`).
        The default is to plot all placed graphs.

        For full details on available parameters, see the specific backend's
        graph manager. For example:

        In [1]: tao.bokeh.plot?
        In [2]: tao.matplotlib.plot?

        Parameters
        ----------
        template : str or list[str]
            Graph template name or names.
        region_name : str, optional
            Graph region name.  Chosen automatically if not specified.
        include_layout : bool, optional
            Include a layout plot at the bottom, if not already placed and if
            appropriate (i.e., another plot uses longitudinal coordinates on
            the x-axis).
        width : int, optional
            Width of each plot.
        height : int, optional
            Height of each plot.
        layout_height : int, optional
            Height of the layout plot.
        share_x : bool or None, default=None
            Share x-axes where sensible (`None`) or force sharing x-axes (True)
            for all plots.
        save : pathlib.Path or str, optional
            Save the plot to the given filename.
        xlim : (float, float), optional
            X axis limits.
        ylim : (float, float), optional
            Y axis limits.
        grid : (nrows, ncols), optional
            If multiple graph names are specified, the plots will be placed
            in a grid according to this parameter.  The default is to have
            stacked plots if this parameter is unspecified.
        backend : {"bokeh", "mpl"}, optional
            The backend to use.  Auto-detects Jupyter and availability of bokeh
            to select a backend.

        Returns
        -------
        None
            To gain access to the resulting plot objects, use the backend's
            `plot` method directly.
        """
        manager = self._get_user_specified_backend(backend)

        if width is not None:
            kwargs["width"] = width
        if height is not None:
            kwargs["height"] = height
        if layout_height is not None:
            kwargs["layout_height"] = layout_height
        if share_x is not None:
            kwargs["share_x"] = share_x

        if not template:
            self.last_plot = manager.plot_all(
                include_layout=include_layout,
                **kwargs,
            )
        elif not isinstance(template, str):
            templates = list(template)
            grid = grid or (len(templates), 1)
            self.last_plot = manager.plot_grid(
                templates=templates,
                grid=grid,
                include_layout=include_layout,
                **kwargs,
            )
        else:
            self.last_plot = manager.plot(
                region_name=region_name,
                template=template,
                include_layout=include_layout,
                **kwargs,
            )

    def plot_field(
        self,
        ele_id: str,
        *,
        colormap: Optional[str] = None,
        radius: float = 0.015,
        num_points: int = 100,
        backend: Optional[str] = None,
        **kwargs,
    ):
        """
        Plot field information for a given element.

        Parameters
        ----------
        ele_id : str
            Element ID.
        colormap : str, optional
            Colormap for the plot.
            Matplotlib defaults to "PRGn_r", and bokeh defaults to "Magma256".
        radius : float, default=0.015
            Radius.
        num_points : int, default=100
            Number of data points.
        backend : {"bokeh", "mpl"}, optional
            The backend to use.  Auto-detects Jupyter and availability of bokeh
            to select a backend.
        """
        manager = self._get_user_specified_backend(backend)
        self.last_plot = manager.plot_field(
            ele_id,
            colormap=colormap,
            radius=radius,
            num_points=num_points,
            **kwargs,
        )

    def beam(self, ix_branch, *, ix_uni="", verbose=False, as_dict=True, raises=True):
        """

        Output beam parameters that are not in the beam_init structure.

        Parameters
        ----------
        ix_uni : optional
        ix_branch : ""

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe beam {ix_uni}@{ix_branch}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {ix_branch} is a lattice branch index. Defaults to s%global%default_branch.

        Note: To set beam_init parameters use the "set beam" command.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/csr_beam_tracking/tao.init
         args:
           ix_uni: 1
           ix_branch: 0

        """
        cmd = f"pipe beam {ix_uni}@{ix_branch}"
        if verbose:
            print(cmd)
        return self.__execute(cmd, as_dict, raises, method_name="beam", cmd_type="string_list")

    def beam_init(self, ix_branch, *, ix_uni="", verbose=False, as_dict=True, raises=True):
        """

        Output beam_init parameters.

        Parameters
        ----------
        ix_uni : optional
        ix_branch : ""

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe beam_init {ix_uni}@{ix_branch}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {ix_branch} is a lattice branch index. Defaults to s%global%default_branch.

        Note: To set beam_init parameters use the "set beam_init" command

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/csr_beam_tracking/tao.init
         args:
           ix_uni: 1
           ix_branch: 0

        """
        cmd = f"pipe beam_init {ix_uni}@{ix_branch}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="beam_init", cmd_type="string_list"
        )

    def bmad_com(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output bmad_com structure components.

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe bmad_com

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe bmad_com"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="bmad_com", cmd_type="string_list"
        )

    def branch1(self, ix_uni, ix_branch, *, verbose=False, as_dict=True, raises=True):
        """

        Output lattice branch information for a particular lattice branch.

        Parameters
        ----------
        ix_uni : ""
        ix_branch : ""

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe branch1 {ix_uni}@{ix_branch}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {ix_branch} is a lattice branch index. Defaults to s%global%default_branch.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni: 1
           ix_branch: 0

        """
        cmd = f"pipe branch1 {ix_uni}@{ix_branch}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="branch1", cmd_type="string_list"
        )

    def bunch_comb(
        self,
        who,
        *,
        ix_uni="",
        ix_branch="",
        ix_bunch="1",
        flags="-array_out",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Outputs bunch parameters at a comb point.
        Also see the "write bunch_comb" and "show bunch -comb" commands.

        Parameters
        ----------
        who
        ix_uni : optional
        ix_branch : optional
        ix_bunch : default=1
        flags : default=-array_out

        Returns
        -------
        string_list
            if '-array_out' not in flags
        real_array
            if '-array_out' in flags

        Notes
        -----
        Command syntax:
          pipe bunch_comb {flags} {who} {ix_uni}@{ix_branch} {ix_bunch}

        Where:
          {flags} are optional switches:
              -array_out : If present, the output will be available in the tao_c_interface_com%c_real.
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {ix_branch} is a branch index. Defaults to s%global%default_branch.
          {ix_bunch} is the bunch index. Defaults to 1.
          {who} is one of:
              x, px, y, py, z, pz, t, s, spin.x, spin.y, spin.z, p0c, beta     -- centroid
              x.Q, y.Q, z.Q, a.Q, b.Q, c.Q where Q is one of: beta, alpha, gamma, phi, eta, etap,
                                                                        sigma, sigma_p, emit, norm_emit
            sigma.IJ where I, J in range [1,6]
            rel_min.I, rel_max.I where I in range [1,6]
            charge_live, n_particle_live, n_particle_lost_in_ele, ix_ele

          Note: If ix_uni or ix_branch is present, "@" must be present.

        Example:
          pipe bunch_comb py 2@1 1

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/csr_beam_tracking/tao.init
         args:
           who: x.beta

        """
        cmd = f"pipe bunch_comb {flags} {who} {ix_uni}@{ix_branch} {ix_bunch}"
        if verbose:
            print(cmd)
        if "-array_out" not in flags:
            return self.__execute(
                cmd, as_dict, raises, method_name="bunch_comb", cmd_type="string_list"
            )
        if "-array_out" in flags:
            return self.__execute(
                cmd, as_dict, raises, method_name="bunch_comb", cmd_type="real_array"
            )

    def bunch_params(self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True):
        """

        Outputs bunch parameters at the exit end of a given lattice element.

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe bunch_params {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe bunch_params end|model  ! parameters at model lattice element named "end".

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/csr_beam_tracking/tao.init
         args:
           ele_id: end
           which: model

        """
        cmd = f"pipe bunch_params {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="bunch_params", cmd_type="string_list"
        )

    def bunch1(
        self,
        ele_id,
        coordinate,
        *,
        which="model",
        ix_bunch="1",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Outputs Bunch parameters at the exit end of a given lattice element.

        Parameters
        ----------
        ele_id
        coordinate
        which : default=model
        ix_bunch : default=1

        Returns
        -------
        real_array
            if coordinate in ['x', 'px', 'y', 'py', 'z', 'pz', 's', 't', 'charge', 'p0c']
        integer_array
            if coordinate in ['state', 'ix_ele']

        Notes
        -----
        Command syntax:
          pipe bunch1 {ele_id}|{which} {ix_bunch} {coordinate}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {ix_bunch} is the bunch index.
          {coordinate} is one of: x, px, y, py, z, pz, "s", "t", "charge", "p0c", "state", "ix_ele"

        For example, if {coordinate} = "px", the phase space px coordinate of each particle
        of the bunch is displayed. The "state" of a particle is an integer. A value of 1 means
        alive and any other value means the particle has been lost.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/csr_beam_tracking/tao.init
         args:
           ele_id: end
           coordinate: x
           which: model
           ix_bunch: 1

        """
        cmd = f"pipe bunch1 {ele_id}|{which} {ix_bunch} {coordinate}"
        if verbose:
            print(cmd)
        if coordinate in ["x", "px", "y", "py", "z", "pz", "s", "t", "charge", "p0c"]:
            return self.__execute(
                cmd, as_dict, raises, method_name="bunch1", cmd_type="real_array"
            )
        if coordinate in ["state", "ix_ele"]:
            return self.__execute(
                cmd, as_dict, raises, method_name="bunch1", cmd_type="integer_array"
            )

    def building_wall_list(self, *, ix_section="", verbose=False, as_dict=True, raises=True):
        """

        Output List of building wall sections or section points

        Parameters
        ----------
        ix_section : optional

        Returns
        -------
        list of dicts

        Notes
        -----
        Command syntax:
          pipe building_wall_list {ix_section}

        Where:
          {ix_section} is a building wall section index.

        If {ix_section} is not present, a list of building wall sections is given.
        If {ix_section} is present, a list of section points is given.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_wall
         args:
           ix_section:

        Example: 2
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_wall
         args:
           ix_section: 1

        """
        cmd = f"pipe building_wall_list {ix_section}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="building_wall_list", cmd_type="string_list"
        )

    def building_wall_graph(self, graph, *, verbose=False, as_dict=True, raises=True):
        """

        Output (x, y) points for drawing the building wall for a particular graph.

        Parameters
        ----------
        graph

        Returns
        -------
        list of dicts

        Notes
        -----
        Command syntax:
          pipe building_wall_graph {graph}

        Where:
          {graph} is a plot region graph name.

        Note: The graph defines the coordinate system for the (x, y) points.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_wall
         args:
           graph: floor_plan.g

        """
        cmd = f"pipe building_wall_graph {graph}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="building_wall_graph", cmd_type="string_list"
        )

    def building_wall_point(
        self,
        ix_section,
        ix_point,
        z,
        x,
        radius,
        z_center,
        x_center,
        *,
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        add or delete a building wall point

        Parameters
        ----------
        ix_section
        ix_point
        z
        x
        radius
        z_center
        x_center

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe building_wall_point {ix_section}^^{ix_point}^^{z}^^{x}^^{radius}^^{z_center}^^{x_center}

        Where:
          {ix_section}    -- Section index.
          {ix_point}      -- Point index. Points of higher indexes will be moved up
                               if adding a point and down if deleting.
          {z}, etc...     -- See tao_building_wall_point_struct components.
                          -- If {z} is set to "delete" then delete the point.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_wall
         args:
           ix_section: 1
           ix_point: 1
           z: 0
           x: 0
           radius: 0
           z_center: 0
           x_center: 0

        """
        cmd = f"pipe building_wall_point {ix_section}^^{ix_point}^^{z}^^{x}^^{radius}^^{z_center}^^{x_center}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="building_wall_point", cmd_type="None"
        )

    def building_wall_section(
        self, ix_section, sec_name, sec_constraint, *, verbose=False, as_dict=True, raises=True
    ):
        """

        Add or delete a building wall section

        Parameters
        ----------
        ix_section
        sec_name
        sec_constraint

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe building_wall_section {ix_section}^^{sec_name}^^{sec_constraint}

        Where:
          {ix_section}      -- Section index. Sections with higher indexes will be
                                 moved up if adding a section and down if deleting.
          {sec_name}        -- Section name.
          {sec_constraint}  -- A section constraint name or "delete". Must be one of:
              delete          -- Delete section. Anything else will add the section.
              none
              left_side
              right_side

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_section: 1
           sec_name: test
           sec_constraint: none

        """
        cmd = f"pipe building_wall_section {ix_section}^^{sec_name}^^{sec_constraint}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="building_wall_section", cmd_type="None"
        )

    def constraints(self, who, *, verbose=False, as_dict=True, raises=True):
        """

        Output optimization data and variable parameters that contribute to the merit function.

        Parameters
        ----------
        who

        Returns
        -------
        list of dicts
            The keys depend on "data" or "var"

        Notes
        -----
        Command syntax:
          pipe constraints {who}

        Where:
          {who} is one of: "data" or "var"

        Data constraints output is:
          data name
          constraint type
          evaluation element name
          start element name
          end/reference element name
          measured value
          ref value (only relavent if global%opt_with_ref = T)
          model value
          base value (only relavent if global%opt_with_base = T)
          weight
          merit value
          location where merit is evaluated (if there is a range)
        Var constraints output is:
          var name
          Associated varible attribute
          meas value
          ref value (only relavent if global%opt_with_ref = T)
          model value
          base value (only relavent if global%opt_with_base = T)
          weight
          merit value
          dmerit/dvar

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           who: data

        Example: 2
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           who:var

        """
        cmd = f"pipe constraints {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="constraints", cmd_type="string_list"
        )

    def da_aperture(self, *, ix_uni="", verbose=False, as_dict=True, raises=True):
        """

        Output dynamic aperture data

        Parameters
        ----------
        ix_uni : optional

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe da_aperture {ix_uni}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.

        """
        cmd = f"pipe da_aperture {ix_uni}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="da_aperture", cmd_type="string_list"
        )

    def da_params(self, *, ix_uni="", verbose=False, as_dict=True, raises=True):
        """

        Output dynamic aperture input parameters

        Parameters
        ----------
        ix_uni : optional

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe da_params {ix_uni}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.

        """
        cmd = f"pipe da_params {ix_uni}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="da_params", cmd_type="string_list"
        )

    def data(
        self,
        d2_name,
        d1_name,
        *,
        ix_uni="",
        dat_index="1",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output Individual datum parameters.

        Parameters
        ----------
        d2_name
        d1_name
        ix_uni : optional
        dat_index : default=1

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe data {ix_uni}@{d2_name}.{d1_name}[{dat_index}]

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {d2_name} is the name of the d2_data structure the datum is in.
          {d1_datum} is the name of the d1_data structure the datum is in.
          {dat_index} is the index of the datum.

        Use the "pipe data-d1" command to get detailed info on a specific d1 array.

        Example:
          pipe data 1@orbit.x[10]

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           ix_uni:
           d2_name: twiss
           d1_name: end
           dat_index: 1

        Example: 2
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           ix_uni: 1
           d2_name: twiss
           d1_name: end
           dat_index: 1

        """
        cmd = f"pipe data {ix_uni}@{d2_name}.{d1_name}[{dat_index}]"
        if verbose:
            print(cmd)
        return self.__execute(cmd, as_dict, raises, method_name="data", cmd_type="string_list")

    def data_d_array(
        self, d2_name, d1_name, *, ix_uni="", verbose=False, as_dict=True, raises=True
    ):
        """

        Output list of datums for a given d1_data structure.

        Parameters
        ----------
        d2_name
        d1_name
        ix_uni : optional

        Returns
        -------
        datums: list of dicts
            Each dict has keys:
            'ix_d1', 'data_type', 'merit_type',
            'ele_ref_name', 'ele_start_name', 'ele_name',
            'meas_value', 'model_value', 'design_value',
            'useit_opt', 'useit_plot', 'good_user',
            'weight', 'exists'

        Notes
        -----
        Command syntax:
          pipe data_d_array {ix_uni}@{d2_name}.{d1_name}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {d2_name} is the name of the containing d2_data structure.
          {d1_name} is the name of the d1_data structure containing the array of datums.

        Example:
          pipe data_d_array 1@orbit.x

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           ix_uni: 1
           d2_name: twiss
           d1_name: end

        """
        cmd = f"pipe data_d_array {ix_uni}@{d2_name}.{d1_name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="data_d_array", cmd_type="string_list"
        )

    def data_d1_array(self, d2_datum, *, ix_uni="", verbose=False, as_dict=True, raises=True):
        """

        Output list of d1 arrays for a given data_d2.

        Parameters
        ----------
        d2_datum
        ix_uni : optional

        Returns
        -------
        list of dicts

        Notes
        -----
        Command syntax:
          pipe data_d1_array {d2_datum}

        {d2_datum} should be of the form
          {ix_uni}@{d2_datum_name}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           ix_uni: 1
           d2_datum: twiss

        """
        cmd = f"pipe data_d1_array {d2_datum}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="data_d1_array", cmd_type="string_list"
        )

    def data_d2(self, d2_name, *, ix_uni="", verbose=False, as_dict=True, raises=True):
        """

        Output information on a d2_datum.

        Parameters
        ----------
        d2_name
        ix_uni : optional

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe data_d2 {ix_uni}@{d2_name}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {d2_name} is the name of the d2_data structure.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           ix_uni: 1
           d2_name: twiss

        """
        cmd = f"pipe data_d2 {ix_uni}@{d2_name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="data_d2", cmd_type="string_list"
        )

    def data_d2_array(self, ix_uni, *, verbose=False, as_dict=True, raises=True):
        """

        Output data d2 info for a given universe.

        Parameters
        ----------
        ix_uni

        Returns
        -------
        list of str

        Notes
        -----
        Command syntax:
          pipe data_d2_array {ix_uni}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.

        Example:
          pipe data_d2_array 1

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni : 1

        """
        cmd = f"pipe data_d2_array {ix_uni}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="data_d2_array", cmd_type="string_list"
        )

    def data_d2_create(
        self,
        d2_name,
        n_d1_data,
        d_data_arrays_name_min_max,
        *,
        ix_uni="",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Create a d2 data structure along with associated d1 and data arrays.

        Parameters
        ----------
        d2_name
        n_d1_data
        d_data_arrays_name_min_max
        ix_uni : optional

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe data_d2_create {ix_uni}@{d2_name}^^{n_d1_data}^^{d_data_arrays_name_min_max}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {d2_name} is the name of the d2_data structure to create.
          {n_d1_data} is the number of associated d1 data structures.
          {d_data_arrays_name_min_max} has the form
            {name1}^^{lower_bound1}^^{upper_bound1}^^....^^{nameN}^^{lower_boundN}^^{upper_boundN}
          where {name} is the data array name and {lower_bound} and {upper_bound} are the bounds of the array.

        Example:
          pipe data_d2_create 2@orbit^^2^^x^^0^^45^^y^^1^^47
        This example creates a d2 data structure called "orbit" with
        two d1 structures called "x" and "y".

        The "x" d1 structure has an associated data array with indexes in the range [0, 45].
        The "y" d1 structure has an associated data arrray with indexes in the range [1, 47].

        Use the "set data" command to set created datum parameters.

        Note: When setting multiple data parameters,
              temporarily toggle s%global%lattice_calc_on to False
          ("set global lattice_calc_on = F") to prevent Tao trying to
              evaluate the partially created datum and generating unwanted error messages.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           ix_uni: 1
           d2_name: orbit
           n_d1_data: 2
           d_data_arrays_name_min_max: x^^0^^45^^y^^1^^47

        """
        cmd = f"pipe data_d2_create {ix_uni}@{d2_name}^^{n_d1_data}^^{d_data_arrays_name_min_max}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="data_d2_create", cmd_type="None"
        )

    def data_d2_destroy(self, d2_name, *, ix_uni="", verbose=False, as_dict=True, raises=True):
        """

        Destroy a d2 data structure along with associated d1 and data arrays.

        Parameters
        ----------
        d2_name
        ix_uni : optional

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe data_d2_destroy {ix_uni}@{d2_name}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {d2_name} is the name of the d2_data structure to destroy.

        Example:
          pipe data_d2_destroy 2@orbit
        This destroys the orbit d2_data structure in universe 2.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           d2_name: orbit

        """
        cmd = f"pipe data_d2_destroy {ix_uni}@{d2_name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="data_d2_destroy", cmd_type="None"
        )

    def data_parameter(
        self, data_array, parameter, *, verbose=False, as_dict=True, raises=True
    ):
        """

        Output an array of values for a particular datum parameter for a given array of datums,

        Parameters
        ----------
        data_array
        parameter

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe data_parameter {data_array} {parameter}

        {parameter} may be any tao_data_struct parameter.
        Example:
          pipe data_parameter orbit.x model_value

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           data_array: twiss.end
           parameter: model_value

        """
        cmd = f"pipe data_parameter {data_array} {parameter}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="data_parameter", cmd_type="string_list"
        )

    def data_set_design_value(self, *, verbose=False, as_dict=True, raises=True):
        """

        Set the design (and base & model) values for all datums.

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe data_set_design_value

        Example:
          pipe data_set_design_value

        Note: Use the "data_d2_create" and "datum_create" first to create datums.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:

        """
        cmd = "pipe data_set_design_value"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="data_set_design_value", cmd_type="None"
        )

    def datum_create(
        self,
        datum_name,
        data_type,
        *,
        ele_ref_name="",
        ele_start_name="",
        ele_name="",
        merit_type="",
        meas="0",
        good_meas="F",
        ref="0",
        good_ref="F",
        weight="0",
        good_user="T",
        data_source="lat",
        eval_point="END",
        s_offset="0",
        ix_bunch="0",
        invalid_value="0",
        spin_axis_n0_1="",
        spin_axis_n0_2="",
        spin_axis_n0_3="",
        spin_axis_l_1="",
        spin_axis_l_2="",
        spin_axis_l_3="",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Create a datum.

        Parameters
        ----------
        datum_name          ! EG: orb.x[3]
        data_type           ! EG: orbit.x
        ele_ref_name : optional
        ele_start_name : optional
        ele_name : optional
        merit_type : optional
        meas : default=0
        good_meas : default=F
        ref : default=0
        good_ref : default=F
        weight : default=0
        good_user : default=T
        data_source : default=lat
        eval_point : default=END
        s_offset : default=0
        ix_bunch : default=0
        invalid_value : default=0
        spin_axis%n0(1) : optional
        spin_axis%n0(2) : optional
        spin_axis%n0(3) : optional
        spin_axis%l(1) : optional
        spin_axis%l(2) : optional
        spin_axis%l(3) : optional

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe datum_create {datum_name}^^{data_type}^^{ele_ref_name}^^{ele_start_name}^^
                              {ele_name}^^{merit_type}^^{meas}^^{good_meas}^^{ref}^^
                              {good_ref}^^{weight}^^{good_user}^^{data_source}^^
                              {eval_point}^^{s_offset}^^{ix_bunch}^^{invalid_value}^^
                              {spin_axis%n0(1)}^^{spin_axis%n0(2)}^^{spin_axis%n0(3)}^^
                              {spin_axis%l(1)}^^{spin_axis%l(2)}^^{spin_axis%l(3)}

        Note: The 3 values for spin_axis%n0, as a group, are optional.
              Also the 3 values for spin_axis%l are, as a group, optional.
        Note: Use the "data_d2_create" first to create a d2 structure with associated d1 arrays.
        Note: After creating all your datums, use the "data_set_design_value" routine to
              set the design (and model) values.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           datum_name: twiss.end[6]
           data_type: beta.y
           ele_ref_name:
           ele_start_name:
           ele_name: P1
           merit_type: target
           meas: 0
           good_meas: T
           ref: 0
           good_ref: T
           weight: 0.3
           good_user: T
           data_source: lat
           eval_point: END
           s_offset: 0
           ix_bunch: 1
           invalid_value: 0

        """
        cmd = f"pipe datum_create {datum_name}^^{data_type}^^{ele_ref_name}^^{ele_start_name}^^{ele_name}^^{merit_type}^^{meas}^^{good_meas}^^{ref}^^{good_ref}^^{weight}^^{good_user}^^{data_source}^^{eval_point}^^{s_offset}^^{ix_bunch}^^{invalid_value}^^{spin_axis_n0_1}^^{spin_axis_n0_2}^^{spin_axis_n0_3}^^{spin_axis_l_1}^^{spin_axis_l_2}^^{spin_axis_l_3}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="datum_create", cmd_type="string_list"
        )

    def datum_has_ele(self, datum_type, *, verbose=False, as_dict=True, raises=True):
        """

        Output whether a datum type has an associated lattice element

        Parameters
        ----------
        datum_type

        Returns
        -------
        str or None
            "no", "yes", "maybe", "provisional"

        Notes
        -----
        Command syntax:
          pipe datum_has_ele {datum_type}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           datum_type: twiss.end

        """
        cmd = f"pipe datum_has_ele {datum_type}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="datum_has_ele", cmd_type="string_list"
        )

    def derivative(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output optimization derivatives

        Returns
        -------
        out : dict
            Dictionary with keys corresponding to universe indexes (int),
            with dModel_dVar as the value:
                np.ndarray with shape (n_data, n_var)

        Notes
        -----
        Command syntax:
          pipe derivative

        Note: To save time, this command will not recalculate derivatives.
        Use the "derivative" command beforehand to recalcuate if needed.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:

        """
        cmd = "pipe derivative"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="derivative", cmd_type="string_list"
        )

    def ele_ac_kicker(
        self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element ac_kicker parameters

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:ac_kicker {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:ac_kicker 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model

        """
        cmd = f"pipe ele:ac_kicker {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_ac_kicker", cmd_type="string_list"
        )

    def ele_cartesian_map(
        self, ele_id, index, who, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element cartesian_map parameters

        Parameters
        ----------
        ele_id
        index
        who
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:cartesian_map {ele_id}|{which} {index} {who}

        Where:
          {ele_id} is an element name or index
          {which} is one of: "model", "base" or "design"
          {index} is the index number in the ele%cartesian_map(:) array
          {who} is one of: "base", or "terms"

        Example:
          pipe ele:cartesian_map 3@1>>7|model 2 base
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_em_field
         args:
          ele_id: 1@0>>1
          which: model
          index: 1
          who: base

        """
        cmd = f"pipe ele:cartesian_map {ele_id}|{which} {index} {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_cartesian_map", cmd_type="string_list"
        )

    def ele_chamber_wall(
        self, ele_id, index, who, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element beam chamber wall parameters

        Parameters
        ----------
        ele_id
        index
        who
        which : default=model

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe ele:chamber_wall {ele_id}|{which} {index} {who}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {index} is index of the wall.
          {who} is one of:
            "x"       ! Return min/max in horizontal plane
            "y"       ! Return min/max in vertical plane

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_wall3d
         args:
          ele_id: 1@0>>1
          which: model
          index: 1
          who: x

        """
        cmd = f"pipe ele:chamber_wall {ele_id}|{which} {index} {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_chamber_wall", cmd_type="string_list"
        )

    def ele_control_var(
        self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output list of element control variables.
        Used for group, overlay and ramper type elements.

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        dict of attributes and values

        Notes
        -----
        Command syntax:
          pipe ele:control_var {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:control_var 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>873
          which: model

        """
        cmd = f"pipe ele:control_var {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_control_var", cmd_type="string_list"
        )

    def ele_cylindrical_map(
        self, ele_id, index, who, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element cylindrical_map

        Parameters
        ----------
        ele_id
        index
        who
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:cylindrical_map {ele_id}|{which} {index} {who}

        Where
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {index} is the index number in the ele%cylindrical_map(:) array
          {who} is one of: "base", or "terms"

        Example:
          pipe ele:cylindrical_map 3@1>>7|model 2 base
        This gives map #2 of element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_em_field
         args:
          ele_id: 1@0>>5
          which: model
          index: 1
          who: base

        """
        cmd = f"pipe ele:cylindrical_map {ele_id}|{which} {index} {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_cylindrical_map", cmd_type="string_list"
        )

    def ele_elec_multipoles(
        self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element electric multipoles

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        dict

        Notes
        -----
        Command syntax:
          pipe ele:elec_multipoles {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:elec_multipoles 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model

        """
        cmd = f"pipe ele:elec_multipoles {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_elec_multipoles", cmd_type="string_list"
        )

    def ele_floor(
        self, ele_id, *, which="model", where="end", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element floor coordinates. The output gives four lines. "Reference" is
        without element misalignments and "Actual" is with misalignments. The lines with "-W"
        give the W matrix. The exception is that if ele is a multipass_lord, there will be 4*N
        lines where N is the number of slaves.

        Parameters
        ----------
        ele_id
        which : default=model
        where : default=end

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:floor {ele_id}|{which} {where}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {where} is an optional argument which, if present, is one of
            beginning  ! Upstream end
            center     ! Middle of element
            end        ! Downstream end (default)
        Note: {where} ignored for photonic elements crystal, mirror, and multilayer_mirror.

        Example:
          pipe ele:floor 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model
          where:

        Example: 2
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model
          where: center

        """
        cmd = f"pipe ele:floor {ele_id}|{which} {where}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_floor", cmd_type="string_list"
        )

    def ele_gen_attribs(
        self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element general attributes

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:gen_attribs {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:gen_attribs 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model

        """
        cmd = f"pipe ele:gen_attribs {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_gen_attribs", cmd_type="string_list"
        )

    def ele_gen_grad_map(
        self, ele_id, index, who, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element gen_grad_map

        Parameters
        ----------
        ele_id
        index
        who
        which : default=model

        Returns
        -------
        dict or list of dict
            "derivs" mode will be a list of dictionaries.
            Normal mode will be a single dictionary.

        Notes
        -----
        Command syntax:
          pipe ele:gen_grad_map {ele_id}|{which} {index} {who}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {index} is the index number in the ele%gen_grad_map(:) array
          {who} is one of: "base", or "derivs".

        Example:
          pipe ele:gen_grad_map 3@1>>7|model 2 base
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_em_field
         args:
          ele_id: 1@0>>9
          which: model
          index: 1
          who: derivs

        """
        cmd = f"pipe ele:gen_grad_map {ele_id}|{which} {index} {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_gen_grad_map", cmd_type="string_list"
        )

    def ele_grid_field(
        self, ele_id, index, who, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element grid_field

        Parameters
        ----------
        ele_id
        index
        who
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:grid_field {ele_id}|{which} {index} {who}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {index} is the index number in the ele%grid_field(:) array.
          {who} is one of: "base", or "points"

        Example:
          pipe ele:grid_field 3@1>>7|model 2 base
        This gives grid #2 of element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_grid
         args:
          ele_id: 1@0>>1
          which: model
          index: 1
          who: base

        """
        cmd = f"pipe ele:grid_field {ele_id}|{which} {index} {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_grid_field", cmd_type="string_list"
        )

    def ele_head(self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True):
        """

        Output "head" Element attributes

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:head {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:head 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model

        """
        cmd = f"pipe ele:head {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_head", cmd_type="string_list"
        )

    def ele_lord_slave(
        self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output the lord/slave tree of an element.

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe ele:lord_slave {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:lord_slave 3@1>>7|model
        This gives lord and slave info on element number 7 in branch 1 of universe 3.
        Note: The lord/slave info is independent of the setting of {which}.

        The output is a number of lines, each line giving information on an element (element index, etc.).
        Some lines begin with the word "Element".
        After each "Element" line, there are a number of lines (possibly zero) that begin with the word "Slave or "Lord".
        These "Slave" and "Lord" lines are the slaves and lords of the "Element" element.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model

        """
        cmd = f"pipe ele:lord_slave {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_lord_slave", cmd_type="string_list"
        )

    def ele_mat6(
        self, ele_id, *, which="model", who="mat6", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element mat6

        Parameters
        ----------
        ele_id
        which : default=model
        who : default=mat6

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:mat6 {ele_id}|{which} {who}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {who} is one of: "mat6", "vec0", or "err"

        Example:
          pipe ele:mat6 3@1>>7|model mat6
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model
          who: mat6

        """
        cmd = f"pipe ele:mat6 {ele_id}|{which} {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_mat6", cmd_type="string_list"
        )

    def ele_methods(self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True):
        """

        Output element methods

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:methods {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:methods 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model

        """
        cmd = f"pipe ele:methods {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_methods", cmd_type="string_list"
        )

    def ele_multipoles(
        self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element multipoles

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        dict

        Notes
        -----
        Command syntax:
          pipe ele:multipoles {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:multipoles 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model

        """
        cmd = f"pipe ele:multipoles {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_multipoles", cmd_type="string_list"
        )

    def ele_orbit(self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True):
        """

        Output element orbit

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:orbit {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:orbit 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model

        """
        cmd = f"pipe ele:orbit {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_orbit", cmd_type="string_list"
        )

    def ele_param(
        self, ele_id, who, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output lattice element parameter

        Parameters
        ----------
        ele_id
        who
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:param {ele_id}|{which} {who}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {who} values are the same as {who} values for "pipe lat_list".
                Note: Here {who} must be a single parameter and not a list.

        Example:
          pipe ele:param 3@1>>7|model e_tot
        This gives E_tot of element number 7 in branch 1 of universe 3.

        Note: On output the {variable} component will always be "F" (since this
        command cannot tell if a parameter is allowed to vary).

        Also see: "pipe lat_list".

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_photon
         args:
          ele_id: 1@0>>1
          which: model
          who: orbit.vec.1

        """
        cmd = f"pipe ele:param {ele_id}|{which} {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_param", cmd_type="string_list"
        )

    def ele_photon(
        self, ele_id, who, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element photon parameters

        Parameters
        ----------
        ele_id
        who
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:photon {ele_id}|{which} {who}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {who} is one of: "base", "material", or "curvature"

        Example:
          pipe ele:photon 3@1>>7|model base
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_photon
         args:
          ele_id: 1@0>>1
          which: model
          who: base

        """
        cmd = f"pipe ele:photon {ele_id}|{which} {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_photon", cmd_type="string_list"
        )

    def ele_spin_taylor(
        self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element spin_taylor parameters

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe ele:spin_taylor {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:spin_taylor 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_spin
         args:
          ele_id: 1@0>>2
          which: model

        """
        cmd = f"pipe ele:spin_taylor {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_spin_taylor", cmd_type="string_list"
        )

    def ele_taylor(self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True):
        """

        Output element taylor map

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        dict

        Notes
        -----
        Command syntax:
          pipe ele:taylor {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:taylor 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_taylor
         args:
          ele_id: 1@0>>34
          which: model

        """
        cmd = f"pipe ele:taylor {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_taylor", cmd_type="string_list"
        )

    def ele_twiss(self, ele_id, *, which="model", verbose=False, as_dict=True, raises=True):
        """

        Output element Twiss parameters

        Parameters
        ----------
        ele_id
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:twiss {ele_id}|{which}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"

        Example:
          pipe ele:twiss 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
          ele_id: 1@0>>1
          which: model

        """
        cmd = f"pipe ele:twiss {ele_id}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_twiss", cmd_type="string_list"
        )

    def ele_wake(
        self, ele_id, who, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element wake.

        Parameters
        ----------
        ele_id
        who
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ele:wake {ele_id}|{which} {who}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {Who} is one of:
              "sr_long"        "sr_long_table"
              "sr_trans"       "sr_trans_table"
              "lr_mode_table"  "base"

        Example:
          pipe ele:wake 3@1>>7|model
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_wake
         args:
          ele_id: 1@0>>1
          which: model
          who: sr_long

        """
        cmd = f"pipe ele:wake {ele_id}|{which} {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_wake", cmd_type="string_list"
        )

    def ele_wall3d(
        self, ele_id, index, who, *, which="model", verbose=False, as_dict=True, raises=True
    ):
        """

        Output element wall3d parameters.

        Parameters
        ----------
        ele_id
        index
        who
        which : default=model

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe ele:wall3d {ele_id}|{which} {index} {who}

        Where:
          {ele_id} is an element name or index.
          {which} is one of: "model", "base" or "design"
          {index} is the index number in the ele%wall3d(:) array (size obtained from "ele:head").
          {who} is one of: "base", or "table".
        Example:
          pipe ele:wall3d 3@1>>7|model 2 base
        This gives element number 7 in branch 1 of universe 3.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_wall3d
         args:
          ele_id: 1@0>>1
          which: model
          index: 1
          who: table

        """
        cmd = f"pipe ele:wall3d {ele_id}|{which} {index} {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ele_wall3d", cmd_type="string_list"
        )

    def evaluate(
        self, expression, *, flags="-array_out", verbose=False, as_dict=True, raises=True
    ):
        """

        Output the value of an expression. The result may be a vector.

        Parameters
        ----------
        expression
        flags : default=-array_out
            If -array_out, the output will be available in the tao_c_interface_com%c_real.

        Returns
        -------
        string_list
            if '-array_out' not in flags
        real_array
            if '-array_out' in flags

        Notes
        -----
        Command syntax:
          pipe evaluate {flags} {expression}

        Where:
          Optional {flags} are:
              -array_out : If present, the output will be available in the tao_c_interface_com%c_real.
          {expression} is expression to be evaluated.

        Example:
          pipe evaluate 3+data::cbar.11[1:10]|model

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           expression: data::cbar.11[1:10]|model

        """
        cmd = f"pipe evaluate {flags} {expression}"
        if verbose:
            print(cmd)
        if "-array_out" not in flags:
            return self.__execute(
                cmd, as_dict, raises, method_name="evaluate", cmd_type="string_list"
            )
        if "-array_out" in flags:
            return self.__execute(
                cmd, as_dict, raises, method_name="evaluate", cmd_type="real_array"
            )

    def em_field(
        self,
        ele_id,
        x,
        y,
        z,
        t_or_z,
        *,
        which="model",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output EM field at a given point generated by a given element.

        Parameters
        ----------
        ele_id
        x
        y
        z
        t_or_z
        which : default=model

        Returns
        -------
        dict

        Notes
        -----
        Command syntax:
          pipe em_field {ele_id}|{which} {x} {y} {z} {t_or_z}

        Where:
          {which} is one of: "model", "base" or "design"
          {x}, {y}  -- Transverse coords.
          {z}       -- Longitudinal coord with respect to entrance end of element.
          {t_or_z}  -- time or phase space z depending if lattice is setup for absolute time tracking.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ele_id: 1@0>>22
           which: model
           x: 0
           y: 0
           z: 0
           t_or_z: 0

        """
        cmd = f"pipe em_field {ele_id}|{which} {x} {y} {z} {t_or_z}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="em_field", cmd_type="string_list"
        )

    def enum(self, enum_name, *, verbose=False, as_dict=True, raises=True):
        """

        Output list of possible values for enumerated numbers.

        Parameters
        ----------
        enum_name

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe enum {enum_name}

        Example:
          pipe enum tracking_method

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           enum_name: tracking_method

        """
        cmd = f"pipe enum {enum_name}"
        if verbose:
            print(cmd)
        return self.__execute(cmd, as_dict, raises, method_name="enum", cmd_type="string_list")

    def floor_plan(self, graph, *, verbose=False, as_dict=True, raises=True):
        """

        Output (x,y) points and other information that can be used for drawing a floor_plan.

        Parameters
        ----------
        graph

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe floor_plan {graph}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           graph: r13.g

        """
        cmd = f"pipe floor_plan {graph}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="floor_plan", cmd_type="string_list"
        )

    def floor_orbit(self, graph, *, verbose=False, as_dict=True, raises=True):
        """

        Output (x, y) coordinates for drawing the particle orbit on a floor plan.

        Parameters
        ----------
        graph

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe floor_orbit {graph}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_floor_orbit
         args:
           graph: r33.g

        """
        cmd = f"pipe floor_orbit {graph}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="floor_orbit", cmd_type="string_list"
        )

    def tao_global(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output global parameters.

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe global

        Output syntax is parameter list form. See documentation at the beginning of this file.

        Note: The follow is intentionally left out:
          optimizer_allow_user_abort
          quiet
          single_step
          prompt_color
          prompt_string

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe global"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="tao_global", cmd_type="string_list"
        )

    def global_optimization(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output optimization parameters.
        Also see global:opti_de.

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe global:optimization

        Output syntax is parameter list form. See documentation at the beginning of this file.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe global:optimization"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="global_optimization", cmd_type="string_list"
        )

    def global_opti_de(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output DE optimization parameters.

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe global:opti_de

        Output syntax is parameter list form. See documentation at the beginning of this file.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe global:opti_de"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="global_opti_de", cmd_type="string_list"
        )

    def help(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output list of "help xxx" topics

        Returns
        -------
        str

        Notes
        -----
        Command syntax:
          pipe help

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe help"
        if verbose:
            print(cmd)
        return self.__execute(cmd, as_dict, raises, method_name="help", cmd_type="string_list")

    def inum(self, who, *, verbose=False, as_dict=True, raises=True):
        """

        Output list of possible values for an INUM parameter.
        For example, possible index numbers for the branches of a lattice.

        Parameters
        ----------
        who

        Returns
        -------
        list of int

        Notes
        -----
        Command syntax:
          pipe inum {who}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           who: ix_universe

        """
        cmd = f"pipe inum {who}"
        if verbose:
            print(cmd)
        return self.__execute(cmd, as_dict, raises, method_name="inum", cmd_type="string_list")

    def lat_calc_done(self, branch_name, *, verbose=False, as_dict=True, raises=True):
        """

        Output if a lattice recalculation has been proformed since the last
          time "pipe lat_calc_done" was called.

        Parameters
        ----------
        branch_name

        Returns
        -------
        bool

        Notes
        -----
        Command syntax:
          pipe lat_calc_done

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           branch_name: 1@0

        """
        cmd = "pipe lat_calc_done"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="lat_calc_done", cmd_type="string_list"
        )

    def lat_ele_list(self, *, branch_name="", verbose=False, as_dict=True, raises=True):
        """

        Output lattice element list.

        Parameters
        ----------
        branch_name : optional

        Returns
        -------
        list of str of element names

        Notes
        -----
        Command syntax:
          pipe lat_ele_list {branch_name}

        {branch_name} should have the form:
          {ix_uni}@{ix_branch}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           branch_name: 1@0

        """
        cmd = f"pipe lat_ele_list {branch_name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="lat_ele_list", cmd_type="string_list"
        )

    def lat_branch_list(self, *, ix_uni="", verbose=False, as_dict=True, raises=True):
        """

        Output lattice branch list

        Parameters
        ----------
        ix_uni : optional

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe lat_branch_list {ix_uni}

        Output syntax:
          branch_index;branch_name;n_ele_track;n_ele_max

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni: 1

        """
        cmd = f"pipe lat_branch_list {ix_uni}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="lat_branch_list", cmd_type="string_list"
        )

    def lat_list(
        self,
        elements,
        who,
        *,
        ix_uni="",
        ix_branch="",
        which="model",
        flags="-array_out -track_only",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output list of parameters at ends of lattice elements

        Parameters
        ----------
        elements
        who
        ix_uni : optional
        ix_branch : optional
        which : default=model
        flags : optional, default=-array_out -track_only

        Returns
        -------
        string_list
            if ('-array_out' not in flags) or (who in ['ele.name', 'ele.key'])
        integer_array
            if '-array_out' in flags and who in ['orbit.state', 'ele.ix_ele']
        real_array
            if ('-array_out' in flags) or ('real:' in who)

        Notes
        -----
        Command syntax:
          pipe lat_list {flags} {ix_uni}@{ix_branch}>>{elements}|{which} {who}

        Where:
         Optional {flags} are:
          -no_slaves : If present, multipass_slave and super_slave elements will not be matched to.
          -track_only : If present, lord elements will not be matched to.
          -index_order : If present, order elements by element index instead of the standard s-position.
          -array_out : If present, the output will be available in the tao_c_interface_com%c_real or
            tao_c_interface_com%c_integer arrays. See the code below for when %c_real vs %c_integer is used.
            Note: Only a single {who} item permitted when -array_out is present.

          {which} is one of: "model", "base" or "design"

          {who} is a comma deliminated list of:
            orbit.floor.x, orbit.floor.y, orbit.floor.z    ! Floor coords at particle orbit.
            orbit.spin.1, orbit.spin.2, orbit.spin.3,
            orbit.vec.1, orbit.vec.2, orbit.vec.3, orbit.vec.4, orbit.vec.5, orbit.vec.6,
            orbit.t, orbit.beta,
            orbit.state,     ! Note: state is an integer. alive$ = 1, anything else is lost.
            orbit.energy, orbit.pc,
            ele.name, ele.key, ele.ix_ele, ele.ix_branch
            ele.a.beta, ele.a.alpha, ele.a.eta, ele.a.etap, ele.a.gamma, ele.a.phi,
            ele.b.beta, ele.b.alpha, ele.b.eta, ele.b.etap, ele.b.gamma, ele.b.phi,
            ele.x.eta, ele.x.etap,
            ele.y.eta, ele.y.etap,
            ele.ref_time, ele.ref_time_start
            ele.s, ele.l
            ele.e_tot, ele.p0c
            ele.mat6      ! Output: mat6(1,:), mat6(2,:), ... mat6(6,:)
            ele.vec0      ! Output: vec0(1), ... vec0(6)
            ele.{attribute} Where {attribute} is a Bmad syntax element attribute. (EG: ele.beta_a, ele.k1, etc.)
            ele.c_mat     ! Output: c_mat11, c_mat12, c_mat21, c_mat22.
            ele.gamma_c   ! Parameter associated with coupling c-matrix.

          {elements} is a string to match element names to.
            Use "*" to match to all elements.

        Examples:
          pipe lat_list -track 3@0>>Q*|base ele.s,orbit.vec.2
          pipe lat_list 3@0>>Q*|base real:ele.s

        Also see: "pipe ele:param"

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni: 1
           ix_branch: 0
           elements: Q*
           which: model
           who: orbit.floor.x

        Example: 2
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni: 1
           ix_branch: 0
           elements: Q*
           which: design
           who: ele.ix_ele

        """
        cmd = f"pipe lat_list {flags} {ix_uni}@{ix_branch}>>{elements}|{which} {who}"
        if verbose:
            print(cmd)
        if ("-array_out" not in flags) or (who in ["ele.name", "ele.key"]):
            return self.__execute(
                cmd, as_dict, raises, method_name="lat_list", cmd_type="string_list"
            )
        if "-array_out" in flags and who in ["orbit.state", "ele.ix_ele"]:
            return self.__execute(
                cmd, as_dict, raises, method_name="lat_list", cmd_type="integer_array"
            )
        if ("-array_out" in flags) or ("real:" in who):
            return self.__execute(
                cmd, as_dict, raises, method_name="lat_list", cmd_type="real_array"
            )

    def lat_param_units(self, param_name, *, verbose=False, as_dict=True, raises=True):
        """

        Output units of a parameter associated with a lattice or lattice element.

        Parameters
        ----------
        param_name

        Returns
        -------
        str

        Notes
        -----
        Command syntax:
          pipe lat_param_units {param_name}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           param_name: L

        """
        cmd = f"pipe lat_param_units {param_name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="lat_param_units", cmd_type="string_list"
        )

    def matrix(self, ele1_id, ele2_id, *, verbose=False, as_dict=True, raises=True):
        """

        Output matrix value from the exit end of one element to the exit end of the other.

        Parameters
        ----------
        ele1_id
        ele2_id

        Returns
        -------
        dict with keys:
            'mat6' : np.array of shape (6,6)
            'vec6' : np.array of shape(6)

        Notes
        -----
        Command syntax:
          pipe matrix {ele1_id} {ele2_id}

        Where:
          {ele1_id} is the start element.
          {ele2_id} is the end element.
        If {ele2_id} = {ele1_id}, the 1-turn transfer map is computed.
        Note: {ele2_id} should just be an element name or index without universe, branch, or model/base/design specification.

        Example:
          pipe matrix 2@1>>q01w|design q02w

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ele1_id: 1@0>>q01w|design
           ele2_id: q02w

        """
        cmd = f"pipe matrix {ele1_id} {ele2_id}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="matrix", cmd_type="string_list"
        )

    def merit(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output merit value.

        Returns
        -------
        merit: float
            Value of the merit function

        Notes
        -----
        Command syntax:
          pipe merit

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe merit"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="merit", cmd_type="string_list"
        )

    def orbit_at_s(
        self,
        *,
        ix_uni="",
        ele="",
        s_offset="",
        which="model",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output twiss at given s position.

        Parameters
        ----------
        ix_uni : optional
        ele : optional
        s_offset : optional
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe orbit_at_s {ix_uni}@{ele}->{s_offset}|{which}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {ele} is an element name or index. Default at the Beginning element at start of branch 0.
          {s_offset} is the offset of the evaluation point from the downstream end of ele. Default is 0.
             If {s_offset} is present, the preceeding "->" sign must be present. EG: Something like "23|model" will
          {which} is one of: "model", "base" or "design".

        Example:
          pipe orbit_at_s Q10->0.4|model   ! Orbit at 0.4 meters from Q10 element exit end in model lattice.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni: 1
           ele: 10
           s_offset: 0.7
           which: model

        """
        cmd = f"pipe orbit_at_s {ix_uni}@{ele}->{s_offset}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="orbit_at_s", cmd_type="string_list"
        )

    def place_buffer(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output the place command buffer and reset the buffer.
        The contents of the buffer are the place commands that the user has issued.
        See the Tao manual for more details.

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe place_buffer

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe place_buffer"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="place_buffer", cmd_type="None"
        )

    def plot_curve(self, curve_name, *, verbose=False, as_dict=True, raises=True):
        """

        Output curve information for a plot.

        Parameters
        ----------
        curve_name

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe plot_curve {curve_name}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           curve_name: r13.g.a

        """
        cmd = f"pipe plot_curve {curve_name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="plot_curve", cmd_type="string_list"
        )

    def plot_graph(self, graph_name, *, verbose=False, as_dict=True, raises=True):
        """

        Output graph info.

        Parameters
        ----------
        graph_name

        Returns
        -------
        dict

        Notes
        -----
        Command syntax:
          pipe plot_graph {graph_name}

        {graph_name} is in the form:
          {p_name}.{g_name}
        where
          {p_name} is the plot region name if from a region or the plot name if a template plot.
          This name is obtained from the pipe plot_list command.
          {g_name} is the graph name obtained from the pipe plot1 command.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           graph_name: beta.g

        """
        cmd = f"pipe plot_graph {graph_name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="plot_graph", cmd_type="string_list"
        )

    def plot_histogram(self, curve_name, *, verbose=False, as_dict=True, raises=True):
        """

        Output plot histogram info.

        Parameters
        ----------
        curve_name

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe plot_histogram {curve_name}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           curve_name: r33.g.x

        """
        cmd = f"pipe plot_histogram {curve_name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="plot_histogram", cmd_type="string_list"
        )

    def plot_lat_layout(
        self, ix_uni: 1, ix_branch: 0, *, verbose=False, as_dict=True, raises=True
    ):
        """

        Output plot Lat_layout info

        Parameters
        ----------
        ix_uni: 1
        ix_branch: 0

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe plot_lat_layout {ix_uni}@{ix_branch}

        Note: The returned list of element positions is not ordered in increasing
              longitudinal position.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni: 1
           ix_branch: 0

        """
        cmd = f"pipe plot_lat_layout {ix_uni}@{ix_branch}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="plot_lat_layout", cmd_type="string_list"
        )

    def plot_list(self, r_or_g, *, verbose=False, as_dict=True, raises=True):
        """

        Output list of plot templates or plot regions.

        Parameters
        ----------
        r_or_g

        Returns
        -------
        if r_or_g == 't'
            dict with template_name:index
        if r_or_g == 'r'
            list of dicts with keys:
                region
                ix
                plot_name
                visible
                x1, x2, y1, y1

        Notes
        -----
        Command syntax:
          pipe plot_list {r_or_g}

        where "{r/g}" is:
          "r"      ! list regions of the form ix;region_name;plot_name;visible;x1;x2;y1;y2
          "t"      ! list template plots of the form ix;name

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           r_or_g: r

        """
        cmd = f"pipe plot_list {r_or_g}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="plot_list", cmd_type="string_list"
        )

    def plot_template_manage(
        self,
        template_location,
        template_name,
        *,
        n_graph="-1",
        graph_names="",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Template plot creation or destruction.

        Parameters
        ----------
        template_location
        template_name
        n_graph : default=-1
        graph_names : default=

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe plot_template_manage {template_location}^^{template_name}^^
                                 {n_graph}^^{graph_names}

        Where:
          {template_location} is the location to place or delete a template plot. Use "@Tnnn" syntax for the location.
          {template_name} is the name of the template plot. If deleting a plot this name is immaterial.
          {n_graph} is the number of associated graphs. If set to -1 then any existing template plot is deleted.
          {graph_names} are the names of the graphs.  graph_names should be in the form:
             graph1_name^^graph2_name^^...^^graphN_name
          for N=n_graph names

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           template_location: @T1
           template_name: beta
           n_graph: 2
           graph_names: g1^^g2

        """
        cmd = f"pipe plot_template_manage {template_location}^^{template_name}^^{n_graph}^^{graph_names}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="plot_template_manage", cmd_type="None"
        )

    def plot_curve_manage(
        self, graph_name, curve_index, curve_name, *, verbose=False, as_dict=True, raises=True
    ):
        """

        Template plot curve creation/destruction

        Parameters
        ----------
        graph_name
        curve_index
        curve_name

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe plot_curve_manage {graph_name}^^{curve_index}^^{curve_name}

        If {curve_index} corresponds to an existing curve then this curve is deleted.
        In this case the {curve_name} is ignored and does not have to be present.
        If {curve_index} does not not correspond to an existing curve, {curve_index}
        must be one greater than the number of curves.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           graph_name: beta.g
           curve_index: 1
           curve_name: r13.g.a

        """
        cmd = f"pipe plot_curve_manage {graph_name}^^{curve_index}^^{curve_name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="plot_curve_manage", cmd_type="None"
        )

    def plot_graph_manage(
        self, plot_name, graph_index, graph_name, *, verbose=False, as_dict=True, raises=True
    ):
        """

        Template plot graph creation/destruction

        Parameters
        ----------
        plot_name
        graph_index
        graph_name

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe plot_graph_manage {plot_name}^^{graph_index}^^{graph_name}

        If {graph_index} corresponds to an existing graph then this graph is deleted.
        In this case the {graph_name} is ignored and does not have to be present.
        If {graph_index} does not not correspond to an existing graph, {graph_index}
        must be one greater than the number of graphs.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           plot_name: beta
           graph_index: 1
           graph_name: beta.g

        """
        cmd = f"pipe plot_graph_manage {plot_name}^^{graph_index}^^{graph_name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="plot_graph_manage", cmd_type="None"
        )

    def plot_line(
        self,
        region_name,
        graph_name,
        curve_name,
        *,
        x_or_y="",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output points used to construct the "line" associated with a plot curve.

        Parameters
        ----------
        region_name
        graph_name
        curve_name
        x_or_y : optional

        Returns
        -------
        string_list
            if x_or_y == ''
        real_array
            if x_or_y != ''

        Notes
        -----
        Command syntax:
          pipe plot_line {region_name}.{graph_name}.{curve_name} {x_or_y}

        Optional {x-or-y} may be set to "x" or "y" to get the smooth line points x or y
        component put into the real array buffer.
        Note: The plot must come from a region, and not a template, since no template plots
              have associated line data.
        Examples:
          pipe plot_line r13.g.a   ! String array output.
          pipe plot_line r13.g.a x ! x-component of line points loaded into the real array buffer.
          pipe plot_line r13.g.a y ! y-component of line points loaded into the real array buffer.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_plot_line -external_plotting
         args:
           region_name: beta
           graph_name: g
           curve_name: a
           x_or_y:

        Example: 2
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_plot_line -external_plotting
         args:
           region_name: beta
           graph_name: g
           curve_name: a
           x_or_y: y

        """
        cmd = f"pipe plot_line {region_name}.{graph_name}.{curve_name} {x_or_y}"
        if verbose:
            print(cmd)
        if x_or_y == "":
            return self.__execute(
                cmd, as_dict, raises, method_name="plot_line", cmd_type="string_list"
            )
        if x_or_y != "":
            return self.__execute(
                cmd, as_dict, raises, method_name="plot_line", cmd_type="real_array"
            )

    def plot_symbol(
        self,
        region_name,
        graph_name,
        curve_name,
        x_or_y,
        *,
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output locations to draw symbols for a plot curve.

        Parameters
        ----------
        region_name
        graph_name
        curve_name
        x_or_y

        Returns
        -------
        string_list
            if x_or_y == ''
        real_array
            if x_or_y != ''

        Notes
        -----
        Command syntax:
          pipe plot_symbol {region_name}.{graph_name}.{curve_name} {x_or_y}

        Optional {x_or_y} may be set to "x" or "y" to get the symbol x or y
        positions put into the real array buffer.
        Note: The plot must come from a region, and not a template,
              since no template plots have associated symbol data.
        Examples:
          pipe plot_symbol r13.g.a       ! String array output.
          pipe plot_symbol r13.g.a x     ! x-component of the symbol positions
                                             loaded into the real array buffer.
          pipe plot_symbol r13.g.a y     ! y-component of the symbol positions
                                             loaded into the real array buffer.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_plot_line -external_plotting
         args:
           region_name: r13
           graph_name: g
           curve_name: a
           x_or_y:

        Example: 2
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_plot_line -external_plotting
         args:
           region_name: r13
           graph_name: g
           curve_name: a
           x_or_y: y

        """
        cmd = f"pipe plot_symbol {region_name}.{graph_name}.{curve_name} {x_or_y}"
        if verbose:
            print(cmd)
        if x_or_y == "":
            return self.__execute(
                cmd, as_dict, raises, method_name="plot_symbol", cmd_type="string_list"
            )
        if x_or_y != "":
            return self.__execute(
                cmd, as_dict, raises, method_name="plot_symbol", cmd_type="real_array"
            )

    def plot_transfer(self, from_plot, to_plot, *, verbose=False, as_dict=True, raises=True):
        """

        Output transfer plot parameters from the "from plot" to the "to plot" (or plots).

        Parameters
        ----------
        from_plot
        to_plot

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe plot_transfer {from_plot} {to_plot}

        To avoid confusion, use "@Tnnn" and "@Rnnn" syntax for {from_plot}.
        If {to_plot} is not present and {from_plot} is a template plot, the "to plots"
         are the equivalent region plots with the same name. And vice versa
         if {from_plot} is a region plot.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           from_plot: r13
           to_plot: r23

        """
        cmd = f"pipe plot_transfer {from_plot} {to_plot}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="plot_transfer", cmd_type="None"
        )

    def plot1(self, name, *, verbose=False, as_dict=True, raises=True):
        """

        Output info on a given plot.

        Parameters
        ----------
        name

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe plot1 {name}

        {name} should be the region name if the plot is associated with a region.
        Output syntax is parameter list form. See documentation at the beginning of this file.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           name: beta

        """
        cmd = f"pipe plot1 {name}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="plot1", cmd_type="string_list"
        )

    def ptc_com(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output Ptc_com structure components.

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ptc_com

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe ptc_com"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ptc_com", cmd_type="string_list"
        )

    def ring_general(
        self,
        *,
        ix_uni="",
        ix_branch="",
        which="model",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output lattice branch with closed geometry info (emittances, etc.)

        Parameters
        ----------
        ix_uni : optional
        ix_branch : optional
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe ring_general {ix_uni}@{ix_branch}|{which}

        where {which} is one of:
          model
          base
          design
        Example:
          pipe ring_general 1@0|model

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
            ix_uni: 1
            ix_branch: 0
            which: model

        """
        cmd = f"pipe ring_general {ix_uni}@{ix_branch}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="ring_general", cmd_type="string_list"
        )

    def shape_list(self, who, *, verbose=False, as_dict=True, raises=True):
        """

        Output lat_layout or floor_plan shapes list

        Parameters
        ----------
        who

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe shape_list {who}

        {who} is one of:
          lat_layout
          floor_plan

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           who: floor_plan

        """
        cmd = f"pipe shape_list {who}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="shape_list", cmd_type="string_list"
        )

    def shape_manage(
        self, who, index, add_or_delete, *, verbose=False, as_dict=True, raises=True
    ):
        """

        Element shape creation or destruction

        Parameters
        ----------
        who
        index
        add_or_delete

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe shape_manage {who} {index} {add_or_delete}

        {who} is one of:
          lat_layout
          floor_plan
        {add_or_delete} is one of:
          add     -- Add a shape at {index}.
                     Shapes with higher index get moved up one to make room.
          delete  -- Delete shape at {index}.
                     Shapes with higher index get moved down one to fill the gap.

        Example:
          pipe shape_manage floor_plan 2 add
        Note: After adding a shape use "pipe shape_set" to set shape parameters.
        This is important since an added shape is in a ill-defined state.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           who: floor_plan
           index: 1
           add_or_delete: add

        """
        cmd = f"pipe shape_manage {who} {index} {add_or_delete}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="shape_manage", cmd_type="string_list"
        )

    def shape_pattern_list(self, *, ix_pattern="", verbose=False, as_dict=True, raises=True):
        """

        Output list of shape patterns or shape pattern points

        Parameters
        ----------
        ix_pattern : optional

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe shape_pattern_list {ix_pattern}

        If optional {ix_pattern} index is omitted then list all the patterns.
        If {ix_pattern} is present, list points of given pattern.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_shape
         args:
           ix_pattern:

        """
        cmd = f"pipe shape_pattern_list {ix_pattern}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="shape_pattern_list", cmd_type="string_list"
        )

    def shape_pattern_manage(
        self, ix_pattern, pat_name, pat_line_width, *, verbose=False, as_dict=True, raises=True
    ):
        """

        Add or remove shape pattern

        Parameters
        ----------
        ix_pattern
        pat_name
        pat_line_width

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe shape_pattern_manage {ix_pattern}^^{pat_name}^^{pat_line_width}

        Where:
          {ix_pattern}      -- Pattern index. Patterns with higher indexes will be moved up
                                              if adding a pattern and down if deleting.
          {pat_name}        -- Pattern name.
          {pat_line_width}  -- Line width. Integer. If set to "delete" then section
                                                    will be deleted.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_shape
         args:
           ix_pattern : 1
           pat_name : new_pat
           pat_line_width : 1

        """
        cmd = f"pipe shape_pattern_manage {ix_pattern}^^{pat_name}^^{pat_line_width}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="shape_pattern_manage", cmd_type="None"
        )

    def shape_pattern_point_manage(
        self, ix_pattern, ix_point, s, x, *, verbose=False, as_dict=True, raises=True
    ):
        """

        Add or remove shape pattern point

        Parameters
        ----------
        ix_pattern
        ix_point
        s
        x

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe shape_pattern_point_manage {ix_pattern}^^{ix_point}^^{s}^^{x}

        Where:
          {ix_pattern}      -- Pattern index.
          {ix_point}        -- Point index. Points of higher indexes will be moved up
                                            if adding a point and down if deleting.
          {s}, {x}          -- Point location. If {s} is "delete" then delete the point.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_shape
         args:
           ix_pattern: 1
           ix_point: 1
           s: 0
           x: 0

        """
        cmd = f"pipe shape_pattern_point_manage {ix_pattern}^^{ix_point}^^{s}^^{x}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="shape_pattern_point_manage", cmd_type="None"
        )

    def shape_set(
        self,
        who,
        shape_index,
        ele_name,
        shape,
        color,
        shape_size,
        type_label,
        shape_draw,
        multi_shape,
        line_width,
        *,
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Set lat_layout or floor_plan shape parameters.

        Parameters
        ----------
        who
        shape_index
        ele_name
        shape
        color
        shape_size
        type_label
        shape_draw
        multi_shape
        line_width

        Returns
        -------
        None

        Notes
        -----
        Command syntax:
          pipe shape_set {who}^^{shape_index}^^{ele_name}^^{shape}^^{color}^^
                           {shape_size}^^{type_label}^^{shape_draw}^^
                           {multi_shape}^^{line_width}

        {who} is one of:
          lat_layout
          floor_plan

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           who: floor_plan
           shape_index: 1
           ele_name: Q1
           shape: circle
           color:
           shape_size:
           type_label:
           shape_draw:
           multi_shape:
           line_width:

        """
        cmd = f"pipe shape_set {who}^^{shape_index}^^{ele_name}^^{shape}^^{color}^^{shape_size}^^{type_label}^^{shape_draw}^^{multi_shape}^^{line_width}"
        if verbose:
            print(cmd)
        return self.__execute(cmd, as_dict, raises, method_name="shape_set", cmd_type="None")

    def show(self, line, *, verbose=False, as_dict=True, raises=True):
        """

        Output the output from a show command.

        Parameters
        ----------
        line

        Returns
        -------
        list of str
            This is raw list of strings from tao, as parsing is not currently
            supported.

        Notes
        -----
        Command syntax:
          pipe show {line}

        {line} is the string to pass through to the show command.
        Example:
          pipe show lattice -pipe

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           line: -pipe

        """
        cmd = f"pipe show {line}"
        if verbose:
            print(cmd)
        return self.__execute(cmd, as_dict, raises, method_name="show", cmd_type="string_list")

    def space_charge_com(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output space_charge_com structure parameters.

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe space_charge_com

        Output syntax is parameter list form. See documentation at the beginning of this file.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe space_charge_com"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="space_charge_com", cmd_type="string_list"
        )

    def species_to_int(self, species_str, *, verbose=False, as_dict=True, raises=True):
        """

        Convert species name to corresponding integer

        Parameters
        ----------
        species_str

        Returns
        -------
        int

        Notes
        -----
        Command syntax:
          pipe species_to_int {species_str}

        Example:
          pipe species_to_int CO2++

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           species_str: electron

        """
        cmd = f"pipe species_to_int {species_str}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="species_to_int", cmd_type="string_list"
        )

    def species_to_str(self, species_int, *, verbose=False, as_dict=True, raises=True):
        """

        Convert species integer id to corresponding

        Parameters
        ----------
        species_int

        Returns
        -------
        str

        Notes
        -----
        Command syntax:
          pipe species_to_str {species_int}

        Example:
          pipe species_to_str -1     ! Returns 'Electron'

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           species_int: -1

        """
        cmd = f"pipe species_to_str {species_int}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="species_to_str", cmd_type="string_list"
        )

    def spin_invariant(
        self,
        who,
        *,
        ix_uni="",
        ix_branch="",
        which="model",
        flags="-array_out",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output closed orbit spin axes n0, l0, or m0 at the ends of all lattice elements in a branch.
        n0, l0, and m0 are solutions of the T-BMT equation.
        n0 is periodic while l0 and m0 are not. At the beginning of the branch, the orientation of the
        l0 or m0 axes in the plane perpendicular to the n0 axis is chosen a bit arbitrarily.
        See the Bmad manual for more details.

        Parameters
        ----------
        who
        ix_uni : optional
        ix_branch : optional
        which : default=model
        flags : default=-array_out

        Returns
        -------
        string_list
            if '-array_out' not in flags
        real_array
            if '-array_out' in flags

        Notes
        -----
        Command syntax:
          pipe spin_invariant {flags} {who} {ix_uni}@{ix_branch}|{which}

        Where:
          {flags} are optional switches:
              -array_out : If present, the output will be available in the tao_c_interface_com%c_real.
          {who} is one of: l0, n0, or m0
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {ix_branch} is a branch index. Defaults to s%global%default_branch.
          {which} is one of:
            model
            base
            design

        Example:
          pipe spin_invariant 1@0|model

        Note: This command is under development. If you want to use please contact David Sagan.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           who: l0
           ix_uni: 1
           ix_branch: 0
           which: model

        """
        cmd = f"pipe spin_invariant {flags} {who} {ix_uni}@{ix_branch}|{which}"
        if verbose:
            print(cmd)
        if "-array_out" not in flags:
            return self.__execute(
                cmd, as_dict, raises, method_name="spin_invariant", cmd_type="string_list"
            )
        if "-array_out" in flags:
            return self.__execute(
                cmd, as_dict, raises, method_name="spin_invariant", cmd_type="real_array"
            )

    def spin_polarization(
        self,
        *,
        ix_uni="",
        ix_branch="",
        which="model",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output spin polarization information

        Parameters
        ----------
        ix_uni : optional
        ix_branch : optional
        which : default=model

        Returns
        -------
        dict

        Notes
        -----
        Command syntax:
          pipe spin_polarization {ix_uni}@{ix_branch}|{which}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {ix_branch} is a branch index. Defaults to s%global%default_branch.
          {which} is one of:
            model
            base
            design

        Example:
          pipe spin_polarization 1@0|model

        Note: This command is under development. If you want to use please contact David Sagan.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni: 1
           ix_branch: 0
           which: model

        """
        cmd = f"pipe spin_polarization {ix_uni}@{ix_branch}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="spin_polarization", cmd_type="string_list"
        )

    def spin_resonance(
        self,
        *,
        ix_uni="",
        ix_branch="",
        which="model",
        ref_ele="0",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output spin resonance information

        Parameters
        ----------
        ix_uni : optional
        ix_branch : optional
        which : default=model
        ref_ele : default=0
            Reference element to calculate at.

        Returns
        -------
        dict

        Notes
        -----
        Command syntax:
          pipe spin_resonance {ix_uni}@{ix_branch}|{which} {ref_ele}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {ix_branch} is a lattice branch index. Defaults to s%global%default_branch.
          {which} is one of: "model", "base" or "design"
          {ref_ele} is an element name or index.
        This will return a string_list with the following fields:
          spin_tune                   -- Spin tune
          dq_X_sum, dq_X_diff         -- Tune sum Q_spin+Q_mode and tune difference Q_spin-Q_mode for modes X = a, b, and c.
          xi_res_X_sum, xi_res_X_diff -- The linear spin/orbit sum and difference resonance strengths for X = a, b, and c modes.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni: 1
           ix_branch: 0
           which: model

        """
        cmd = f"pipe spin_resonance {ix_uni}@{ix_branch}|{which} {ref_ele}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="spin_resonance", cmd_type="string_list"
        )

    def super_universe(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output super_Universe parameters.

        Returns
        -------
        dict

        Notes
        -----
        Command syntax:
          pipe super_universe

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe super_universe"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="super_universe", cmd_type="string_list"
        )

    def taylor_map(
        self, ele1_id, ele2_id, *, order="1", verbose=False, as_dict=True, raises=True
    ):
        """

        Output Taylor map between two points.

        Parameters
        ----------
        ele1_id
        ele2_id
        order : default=1

        Returns
        -------
        dict of dict of taylor terms:
            {2: { (3,0,0,0,0,0)}: 4.56, ...
                corresponding to: px_out = 4.56 * x_in^3

        Notes
        -----
        Command syntax:
          pipe taylor_map {ele1_id} {ele2_id} {order}

        Where:
          {ele1_id} is the start element.
          {ele2_id} is the end element.
          {order} is the map order. Default is order set in the lattice file. {order} cannot be larger than
                what is set by the lattice file.
        If {ele2_id} = {ele1_id}, the 1-turn transfer map is computed.
        Note: {ele2_id} should just be an element name or index without universe, branch, or model/base/design specification.
        Example:
          pipe taylor_map 2@1>>q01w|design q02w  2

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ele1_id: 1@0>>q01w|design
           ele2_id: q02w
           order: 1

        """
        cmd = f"pipe taylor_map {ele1_id} {ele2_id} {order}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="taylor_map", cmd_type="string_list"
        )

    def twiss_at_s(
        self,
        *,
        ix_uni="",
        ele="",
        s_offset="",
        which="model",
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Output twiss parameters at given s position.

        Parameters
        ----------
        ix_uni : optional
        ele : optional
        s_offset : optional
        which : default=model

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe twiss_at_s {ix_uni}@{ele}->{s_offset}|{which}

        Where:
          {ix_uni} is a universe index. Defaults to s%global%default_universe.
          {ele} is an element name or index. Default at the Beginning element at start of branch 0.
          {s_offset} is the offset of the evaluation point from the downstream end of ele. Default is 0.
             If {s_offset} is present, the preceeding "->" sign must be present. EG: Something like "23|model" will
          {which} is one of: "model", "base" or "design".

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni: 1
           ele: 10
           s_offset: 0.7
           which: model

        """
        cmd = f"pipe twiss_at_s {ix_uni}@{ele}->{s_offset}|{which}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="twiss_at_s", cmd_type="string_list"
        )

    def universe(self, ix_uni, *, verbose=False, as_dict=True, raises=True):
        """

        Output universe info.

        Parameters
        ----------
        ix_uni

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe universe {ix_uni}

        Use "pipe global" to get the number of universes.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           ix_uni: 1

        """
        cmd = f"pipe universe {ix_uni}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="universe", cmd_type="string_list"
        )

    def var(self, var, *, slaves="", verbose=False, as_dict=True, raises=True):
        """

        Output parameters of a given variable.

        Parameters
        ----------
        var
        slaves : optional

        Returns
        -------
        dict, or list of dict
            "slaves" mode will be a list of dicts.
            Normal mode will be a dict.

        Notes
        -----
        Command syntax:
          pipe var {var} {slaves}

        Note: use "pipe var_general" to get a list of variables.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           var: quad[1]
           slaves:

        Example: 2
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           var: quad[1]
           slaves: slaves

        """
        cmd = f"python var {var} {slaves}"
        if verbose:
            print(cmd)
        return self.__execute(cmd, as_dict, raises, method_name="var", cmd_type="string_list")

    def var_create(
        self,
        var_name,
        ele_name,
        attribute,
        universes,
        weight,
        step,
        low_lim,
        high_lim,
        merit_type,
        good_user,
        key_bound,
        key_delta,
        *,
        verbose=False,
        as_dict=True,
        raises=True,
    ):
        """

        Create a single variable

        Parameters
        ----------
        var_name
        ele_name
        attribute
        universes
        weight
        step
        low_lim
        high_lim
        merit_type
        good_user
        key_bound
        key_delta

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe var_create {var_name}^^{ele_name}^^{attribute}^^{universes}^^
                            {weight}^^{step}^^{low_lim}^^{high_lim}^^{merit_type}^^
                            {good_user}^^{key_bound}^^{key_delta}

        {var_name} is something like "kick[5]".
        Before using var_create, setup the appropriate v1_var array using
        the "pipe var_v1_create" command.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/tao.init_optics_matching
         args:
           var_name: quad[1]
           ele_name: Q1
           attribute: L
           universes: 1
           weight: 0.001
           step: 0.001
           low_lim: -10
           high_lim: 10
           merit_type:
           good_user: T
           key_bound: T
           key_delta: 0.01

        """
        cmd = f"pipe var_create {var_name}^^{ele_name}^^{attribute}^^{universes}^^{weight}^^{step}^^{low_lim}^^{high_lim}^^{merit_type}^^{good_user}^^{key_bound}^^{key_delta}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="var_create", cmd_type="string_list"
        )

    def var_general(self, *, verbose=False, as_dict=True, raises=True):
        """

        Output list of all variable v1 arrays

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe var_general

        Output syntax:
          {v1_var name};{v1_var%v lower bound};{v1_var%v upper bound}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:

        """
        cmd = "pipe var_general"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="var_general", cmd_type="string_list"
        )

    def var_v_array(self, v1_var, *, verbose=False, as_dict=True, raises=True):
        """

        Output list of variables for a given data_v1.

        Parameters
        ----------
        v1_var

        Returns
        -------
        list of dict

        Notes
        -----
        Command syntax:
          pipe var_v_array {v1_var}

        Example:
          pipe var_v_array quad_k1

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           v1_var: quad_k1

        """
        cmd = f"pipe var_v_array {v1_var}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="var_v_array", cmd_type="string_list"
        )

    def var_v1_array(self, v1_var, *, verbose=False, as_dict=True, raises=True):
        """

        Output list of variables in a given variable v1 array

        Parameters
        ----------
        v1_var

        Returns
        -------
        dict

        Notes
        -----
        Command syntax:
          pipe var_v1_array {v1_var}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           v1_var: quad_k1

        """
        cmd = f"pipe var_v1_array {v1_var}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="var_v1_array", cmd_type="string_list"
        )

    def var_v1_create(
        self, v1_name, n_var_min, n_var_max, *, verbose=False, as_dict=True, raises=True
    ):
        """

        Create a v1 variable structure along with associated var array.

        Parameters
        ----------
        v1_name
        n_var_min
        n_var_max

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe var_v1_create {v1_name} {n_var_min} {n_var_max}

        {n_var_min} and {n_var_max} are the lower and upper bounds of the var
        Example:
          pipe var_v1_create quad_k1 0 45
        This example creates a v1 var structure called "quad_k1" with an associated
        variable array that has the range [0, 45].

        Use the "set variable" command to set a created variable parameters.
        In particular, to slave a lattice parameter to a variable use the command:
          set {v1_name}|ele_name = {lat_param}
        where {lat_param} is of the form {ix_uni}@{ele_name_or_location}{param_name}]
        Examples:
          set quad_k1[2]|ele_name = 2@q01w[k1]
          set quad_k1[2]|ele_name = 2@0>>10[k1]
        Note: When setting multiple variable parameters,
              temporarily toggle s%global%lattice_calc_on to False
          ("set global lattice_calc_on = F") to prevent Tao trying to evaluate the
        partially created variable and generating unwanted error messages.

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           v1_name: quad_k1
           n_var_min: 0
           n_var_max: 45

        """
        cmd = f"pipe var_v1_create {v1_name} {n_var_min} {n_var_max}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="var_v1_create", cmd_type="string_list"
        )

    def var_v1_destroy(self, v1_datum, *, verbose=False, as_dict=True, raises=True):
        """

        Destroy a v1 var structure along with associated var sub-array.

        Parameters
        ----------
        v1_datum

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe var_v1_destroy {v1_datum}

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           v1_datum: quad_k1

        """
        cmd = f"pipe var_v1_destroy {v1_datum}"
        if verbose:
            print(cmd)
        return self.__execute(
            cmd, as_dict, raises, method_name="var_v1_destroy", cmd_type="string_list"
        )

    def wave(self, who, *, verbose=False, as_dict=True, raises=True):
        """

        Output Wave analysis info.

        Parameters
        ----------
        who

        Returns
        -------
        string_list

        Notes
        -----
        Command syntax:
          pipe wave {who}

        Where {who} is one of:
          params
          loc_header
          locations
          plot1, plot2, plot3

        Examples
        --------
        Example: 1
         init: -init $ACC_ROOT_DIR/regression_tests/pipe_test/cesr/tao.init
         args:
           who: params

        """
        cmd = f"pipe wave {who}"
        if verbose:
            print(cmd)
        return self.__execute(cmd, as_dict, raises, method_name="wave", cmd_type="string_list")
